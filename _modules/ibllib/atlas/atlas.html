

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ibllib.atlas.atlas &mdash; IBL Library  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/style.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> IBL Library
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../01_overview.html">IBL data structure</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../02_installation.html">Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../03_one.html">ONE</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../04_datajoint.html">Datajoint</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../05_tutorials.html">Tutorials</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../06_examples.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../07_developers.html">API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">IBL Library</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>ibllib.atlas.atlas</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ibllib.atlas.atlas</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">nrrd</span>

<span class="kn">from</span> <span class="nn">brainbox.core</span> <span class="kn">import</span> <span class="n">Bunch</span><span class="p">,</span> <span class="n">ismember</span>
<span class="kn">from</span> <span class="nn">ibllib.io</span> <span class="kn">import</span> <span class="n">params</span>
<span class="kn">from</span> <span class="nn">oneibl.webclient</span> <span class="kn">import</span> <span class="n">http_download_file</span>

<span class="n">ALLEN_CCF_LANDMARKS_MLAPDV_UM</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bregma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5739</span><span class="p">,</span> <span class="mi">5400</span><span class="p">,</span> <span class="mi">332</span><span class="p">])}</span>
<span class="n">FILE_REGIONS</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;allen_structure_tree.csv&#39;</span><span class="p">))</span>


<div class="viewcode-block" id="cart2sph"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.cart2sph">[docs]</a><span class="k">def</span> <span class="nf">cart2sph</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts cartesian to spherical Coordinates</span>
<span class="sd">    theta: polar angle, phi: azimuth</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">iok</span> <span class="o">=</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">theta</span><span class="p">[</span><span class="n">iok</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">iok</span><span class="p">]</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="n">iok</span><span class="p">])</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span></div>


<div class="viewcode-block" id="sph2cart"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.sph2cart">[docs]</a><span class="k">def</span> <span class="nf">sph2cart</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts Spherical to Cartesian coordinates</span>
<span class="sd">    theta: polar angle, phi: azimuth</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span></div>


<div class="viewcode-block" id="BrainCoordinates"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates">[docs]</a><span class="k">class</span> <span class="nc">BrainCoordinates</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for mapping and indexing a 3D array to real-world coordinates</span>
<span class="sd">    x = ml, right positive</span>
<span class="sd">    y = ap, anterior positive</span>
<span class="sd">    z = dv, dorsal positive</span>

<span class="sd">    The layout of the Atlas dimension is done according to the most used sections so they lay</span>
<span class="sd">    contiguous on disk assuming C-ordering: V[iap, iml, idv]</span>

<span class="sd">    nxyz: number of elements along each cartesian axis (nx, ny, nz) = (nml, nap, ndv)</span>
<span class="sd">    xyz0: coordinates of the element volume[0, 0, 0]] in the coordinate space</span>
<span class="sd">    dxyz: spatial interval of the volume along the 3 dimensions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nxyz</span><span class="p">,</span> <span class="n">xyz0</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dxyz</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dxyz</span><span class="p">):</span>
            <span class="n">dxyz</span> <span class="o">=</span> <span class="p">[</span><span class="n">dxyz</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xyz0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dxyz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nxyz</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">])</span>

    <span class="sd">&quot;&quot;&quot;Methods ratios to indice&quot;&quot;&quot;</span>
<div class="viewcode-block" id="BrainCoordinates.r2ix"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.r2ix">[docs]</a>    <span class="k">def</span> <span class="nf">r2ix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainCoordinates.r2iy"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.r2iy">[docs]</a>    <span class="k">def</span> <span class="nf">r2iy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainCoordinates.r2iz"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.r2iz">[docs]</a>    <span class="k">def</span> <span class="nf">r2iz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span></div>

    <span class="sd">&quot;&quot;&quot;Methods distance to indice&quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_round</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">nanval</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">round</span><span class="p">:</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="n">ii</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">nanval</span>
            <span class="k">return</span> <span class="n">ii</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>

<div class="viewcode-block" id="BrainCoordinates.x2i"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.x2i">[docs]</a>    <span class="k">def</span> <span class="nf">x2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainCoordinates.y2i"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.y2i">[docs]</a>    <span class="k">def</span> <span class="nf">y2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round</span><span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainCoordinates.z2i"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.z2i">[docs]</a>    <span class="k">def</span> <span class="nf">z2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_round</span><span class="p">((</span><span class="n">z</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">z0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainCoordinates.xyz2i"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.xyz2i">[docs]</a>    <span class="k">def</span> <span class="nf">xyz2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span> <span class="k">if</span> <span class="nb">round</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="nb">round</span><span class="o">=</span><span class="nb">round</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

    <span class="sd">&quot;&quot;&quot;Methods indices to distance&quot;&quot;&quot;</span>
<div class="viewcode-block" id="BrainCoordinates.i2x"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.i2x">[docs]</a>    <span class="k">def</span> <span class="nf">i2x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ind</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span></div>

<div class="viewcode-block" id="BrainCoordinates.i2y"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.i2y">[docs]</a>    <span class="k">def</span> <span class="nf">i2y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ind</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y0</span></div>

<div class="viewcode-block" id="BrainCoordinates.i2z"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.i2z">[docs]</a>    <span class="k">def</span> <span class="nf">i2z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ind</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">z0</span></div>

<div class="viewcode-block" id="BrainCoordinates.i2xyz"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.i2xyz">[docs]</a>    <span class="k">def</span> <span class="nf">i2xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iii</span><span class="p">):</span>
        <span class="n">iii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">iii</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">iii</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2x</span><span class="p">(</span><span class="n">iii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2y</span><span class="p">(</span><span class="n">iii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">iii</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">out</span></div>

    <span class="sd">&quot;&quot;&quot;Methods bounds&quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xlim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2x</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ylim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2y</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zlim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>

<div class="viewcode-block" id="BrainCoordinates.lim"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainCoordinates.lim">[docs]</a>    <span class="k">def</span> <span class="nf">lim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xlim</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ylim</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zlim</span></div>

    <span class="sd">&quot;&quot;&quot;returns scales&quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2x</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">yscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2y</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">))</span>

    <span class="sd">&quot;&quot;&quot;returns the 3d mgrid used for 3d visualization&quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xscale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yscale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zscale</span><span class="p">)</span></div>


<div class="viewcode-block" id="BrainAtlas"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas">[docs]</a><span class="k">class</span> <span class="nc">BrainAtlas</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Objects that holds image, labels and coordinate transforms for a brain Atlas.</span>
<span class="sd">    Currently this is designed for the AllenCCF at several resolutions,</span>
<span class="sd">    yet this class can be used for other atlases arises.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">dxyz</span><span class="p">,</span> <span class="n">regions</span><span class="p">,</span> <span class="n">iorigin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                 <span class="n">dims2xyz</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">xyz2dims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        self.image: image volume (ap, ml, dv)</span>
<span class="sd">        self.label: label volume (ap, ml, dv)</span>
<span class="sd">        self.bc: atlas.BrainCoordinate object</span>
<span class="sd">        self.regions: atlas.BrainRegions object</span>
<span class="sd">        self.top: 2d np array (ap, ml) containing the z-coordinate (m) of the surface of the brain</span>
<span class="sd">        self.dims2xyz and self.zyz2dims: map image axis order to xyz coordinates order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regions</span> <span class="o">=</span> <span class="n">regions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dims2xyz</span> <span class="o">=</span> <span class="n">dims2xyz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span> <span class="o">=</span> <span class="n">xyz2dims</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims2xyz</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dims2xyz</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
        <span class="c1"># create the coordinate transform object that maps volume indices to real world coordinates</span>
        <span class="n">nxyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">dims2xyz</span><span class="p">]</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">BrainCoordinates</span><span class="p">(</span><span class="n">nxyz</span><span class="o">=</span><span class="n">nxyz</span><span class="p">,</span> <span class="n">xyz0</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dxyz</span><span class="o">=</span><span class="n">dxyz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">=</span> <span class="n">BrainCoordinates</span><span class="p">(</span><span class="n">nxyz</span><span class="o">=</span><span class="n">nxyz</span><span class="p">,</span> <span class="n">xyz0</span><span class="o">=-</span> <span class="n">bc</span><span class="o">.</span><span class="n">i2xyz</span><span class="p">(</span><span class="n">iorigin</span><span class="p">),</span> <span class="n">dxyz</span><span class="o">=</span><span class="n">dxyz</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the volume top surface, this is needed to compute probe insertions intersections</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># this is the dv axis</span>
        <span class="n">l0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axz</span><span class="p">)</span>
        <span class="n">_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">l0</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axz</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">_top</span><span class="p">[</span><span class="n">_top</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">_bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nz</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axz</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axz</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">_bottom</span><span class="p">[</span><span class="n">_bottom</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">_top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2z</span><span class="p">(</span><span class="n">_bottom</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_lookup_inds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ixyz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a 3D lookup from volume indices ixyz to the image volume</span>
<span class="sd">        :param ixyz: [n, 3] array of indices in the mlapdv order</span>
<span class="sd">        :return: n array of label values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ixyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">idims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nxyz</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">inds</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a 3D lookup from real world coordinates to the flat indices in the volume</span>
<span class="sd">        defined in the BrainCoordinates object</span>
<span class="sd">        :param xyz: [n, 3] array of coordinates</span>
<span class="sd">        :return: n array of label values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_inds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">))</span>

<div class="viewcode-block" id="BrainAtlas.get_labels"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.get_labels">[docs]</a>    <span class="k">def</span> <span class="nf">get_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a 3D lookup from real world coordinates to the volume labels</span>
<span class="sd">        :param xyz: [n, 3] array of coordinates</span>
<span class="sd">        :return: n array of label values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_lookup</span><span class="p">(</span><span class="n">xyz</span><span class="p">)]</span></div>

    <span class="k">def</span> <span class="nf">_label2rgb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imlabel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a slice from the label volume to its RGB equivalent for display</span>
<span class="sd">        :param imlabel: 2D np-array containing label ids (slice of the label volume)</span>
<span class="sd">        :return: 3D np-array of the slice uint8 rgb values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="p">,</span> <span class="s1">&#39;rgb&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">imlabel</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if the regions exist and have the rgb attribute, do the rgb lookup</span>
            <span class="c1"># the lookup is done in pure numpy for speed. This is the ismember matlab fcn</span>
            <span class="n">im_unique</span><span class="p">,</span> <span class="n">ilabels</span><span class="p">,</span> <span class="n">iim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">imlabel</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ir_unique</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">im_unique</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="o">.</span><span class="n">rgb</span><span class="p">[</span><span class="n">ir_unique</span><span class="p">[</span><span class="n">iim</span><span class="p">],</span> <span class="p">:],</span> <span class="p">(</span><span class="o">*</span><span class="n">imlabel</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<div class="viewcode-block" id="BrainAtlas.tilted_slice"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.tilted_slice">[docs]</a>    <span class="k">def</span> <span class="nf">tilted_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From line coordinates, extracts the tilted plane containing the line from the 3D volume</span>
<span class="sd">        :param xyz: np.array: points defining a probe trajectory in 3D space (xyz triplets)</span>
<span class="sd">        if more than 2 points are provided will take the best fit</span>
<span class="sd">        :param axis:</span>
<span class="sd">            0: along ml = sagittal-slice</span>
<span class="sd">            1: along ap = coronal-slice</span>
<span class="sd">            2: along dv = horizontal-slice</span>
<span class="sd">        :param volume: &#39;image&#39; or &#39;annotation&#39;</span>
<span class="sd">        :return: np.array, abscissa extent (width), ordinate extent (height),</span>
<span class="sd">        squeezed axis extent (depth)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># sagittal slice (squeeze/take along ml-axis)</span>
            <span class="n">wdim</span><span class="p">,</span> <span class="n">hdim</span><span class="p">,</span> <span class="n">ddim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># coronal slice (squeeze/take along ap-axis)</span>
            <span class="n">wdim</span><span class="p">,</span> <span class="n">hdim</span><span class="p">,</span> <span class="n">ddim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># horizontal slice (squeeze/take along dv-axis)</span>
            <span class="n">wdim</span><span class="p">,</span> <span class="n">hdim</span><span class="p">,</span> <span class="n">ddim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># get the best fit and find exit points of the volume along squeezed axis</span>
        <span class="n">trj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">sub_volume</span> <span class="o">=</span> <span class="n">trj</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">hdim</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">hdim</span><span class="p">)</span>
        <span class="n">sub_volume</span><span class="p">[:,</span> <span class="n">wdim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">wdim</span><span class="p">)</span>
        <span class="n">sub_volume_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">sub_volume</span><span class="p">)</span>
        <span class="n">tile_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sub_volume_i</span><span class="p">[:,</span> <span class="n">hdim</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nxyz</span><span class="p">[</span><span class="n">wdim</span><span class="p">]])</span>
        <span class="c1"># get indices along each dimension</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tile_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">indy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tile_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">sub_volume_i</span><span class="p">[:,</span> <span class="n">ddim</span><span class="p">],</span> <span class="n">tile_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># compute the slice indices and output the slice</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">INDS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">inds</span><span class="p">)))</span>
        <span class="n">INDX</span><span class="p">,</span> <span class="n">INDY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">indy</span><span class="p">)</span>
        <span class="n">indsl</span> <span class="o">=</span> <span class="p">[[</span><span class="n">INDX</span><span class="p">,</span> <span class="n">INDY</span><span class="p">,</span> <span class="n">INDS</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="n">wdim</span><span class="p">,</span> <span class="n">hdim</span><span class="p">,</span> <span class="n">ddim</span><span class="p">])[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">tslice</span> <span class="o">=</span> <span class="n">volume</span><span class="p">[</span><span class="n">indsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">volume</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span>
            <span class="n">tslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label2rgb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">indsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="n">volume</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="n">tslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">indsl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indsl</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

        <span class="c1">#  get extents with correct convention NB: matplotlib flips the y-axis on imshow !</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_volume</span><span class="p">[:,</span> <span class="n">wdim</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">wdim</span><span class="p">))]</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_volume</span><span class="p">[:,</span> <span class="n">hdim</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">hdim</span><span class="p">))])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sub_volume</span><span class="p">[:,</span> <span class="n">ddim</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">lim</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">ddim</span><span class="p">))])</span>
        <span class="k">return</span> <span class="n">tslice</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span></div>

<div class="viewcode-block" id="BrainAtlas.plot_tilted_slice"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.plot_tilted_slice">[docs]</a>    <span class="k">def</span> <span class="nf">plot_tilted_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From line coordinates, extracts the tilted plane containing the line from the 3D volume</span>
<span class="sd">        :param xyz: np.array: points defining a probe trajectory in 3D space (xyz triplets)</span>
<span class="sd">        if more than 2 points are provided will take the best fit</span>
<span class="sd">        :param axis:</span>
<span class="sd">            0: along ml = sagittal-slice</span>
<span class="sd">            1: along ap = coronal-slice</span>
<span class="sd">            2: along dv = horizontal-slice</span>
<span class="sd">        :param volume: &#39;image&#39; or &#39;annotation&#39;</span>
<span class="sd">        :return: matplotlib axis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ap (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;dv (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;ml (um)&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">axis_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ml (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;dv (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;ap (um)&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">axis_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ml (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;ap (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;dv (um)&#39;</span><span class="p">])</span>

        <span class="n">tslice</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tilted_slice</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cmap</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;bone&#39;</span><span class="p">)</span>
        <span class="c1"># get the transfer function from y-axis to squeezed axis for second axe</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">height</span><span class="p">,</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">depth</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">*</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">tslice</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">sec_ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">secondary_yaxis</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">functions</span><span class="o">=</span><span class="p">(</span>
                                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">axis_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">axis_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sec_ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">axis_labels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ax</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_plot_slice</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cmap</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;bone&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

<div class="viewcode-block" id="BrainAtlas.slice"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param coordinate: float</span>
<span class="sd">        :param axis: xyz convention:  0 for ml, 1 for ap, 2</span>
<span class="sd">        :param volume: &#39;image&#39; or &#39;annotation&#39;</span>
<span class="sd">        :return: 2d array or 3d RGB numpy int8 array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coordinate</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">volume</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label2rgb</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">volume</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz2dims</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span></div>

<div class="viewcode-block" id="BrainAtlas.plot_cslice"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.plot_cslice">[docs]</a>    <span class="k">def</span> <span class="nf">plot_cslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ap_coordinate</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Imshow a coronal slice</span>
<span class="sd">        :param: ap_coordinate (m)</span>
<span class="sd">        :param volume: &#39;image&#39; or &#39;annotation&#39;</span>
<span class="sd">        :return: ax</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">ap_coordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">)]</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_slice</span><span class="p">(</span><span class="n">cslice</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainAtlas.plot_hslice"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.plot_hslice">[docs]</a>    <span class="k">def</span> <span class="nf">plot_hslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dv_coordinate</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Imshow a horizontal slice</span>
<span class="sd">        :param: dv_coordinate (m)</span>
<span class="sd">        :param volume: &#39;image&#39; or &#39;annotation&#39;</span>
<span class="sd">        :return: ax</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">dv_coordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">)]</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_slice</span><span class="p">(</span><span class="n">hslice</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainAtlas.plot_sslice"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.plot_sslice">[docs]</a>    <span class="k">def</span> <span class="nf">plot_sslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ml_coordinate</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Imshow a sagittal slice</span>
<span class="sd">        :param: ml_coordinate (m)</span>
<span class="sd">        :param volume: &#39;image&#39; or &#39;annotation&#39;</span>
<span class="sd">        :return: ax</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sslice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">ml_coordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">)</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">)]</span> <span class="o">*</span> <span class="mf">1e6</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plot_slice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">sslice</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainAtlas.plot_top"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainAtlas.plot_top">[docs]</a>    <span class="k">def</span> <span class="nf">plot_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">nx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">ny</span><span class="p">))</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">z2i</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lookup_inds</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label2rgb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">inds</span><span class="p">]),</span>
                  <span class="n">extent</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">)]</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;upper&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div></div>


<div class="viewcode-block" id="Trajectory"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Trajectory</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3D Trajectory (usually for a linear probe). Minimally defined by a vector and a point.</span>
<span class="sd">    instantiate from a best fit from a n by 3 array containing xyz coordinates:</span>
<span class="sd">        trj = Trajectory.fit(xyz)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">point</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

<div class="viewcode-block" id="Trajectory.fit"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.fit">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="n">xyz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        fits a line to a 3D cloud of points, returns a Trajectory object</span>
<span class="sd">        :param xyz: n by 3 numpy array containing cloud of points</span>
<span class="sd">        :returns: a Trajectory object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Trajectory</span><span class="p">(</span><span class="n">vector</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">xyz_mean</span><span class="p">)[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="o">=</span><span class="n">xyz_mean</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trajectory.eval_x"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.eval_x">[docs]</a>    <span class="k">def</span> <span class="nf">eval_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        given an array of x coordinates, returns the xyz array of coordinates along the insertion</span>
<span class="sd">        :param x: n by 1 or numpy array containing x-coordinates</span>
<span class="sd">        :return: n by 3 numpy array containing xyz-coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trajectory.eval_y"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.eval_y">[docs]</a>    <span class="k">def</span> <span class="nf">eval_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        given an array of y coordinates, returns the xyz array of coordinates along the insertion</span>
<span class="sd">        :param y: n by 1 or numpy array containing y-coordinates</span>
<span class="sd">        :return: n by 3 numpy array containing xyz-coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trajectory.eval_z"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.eval_z">[docs]</a>    <span class="k">def</span> <span class="nf">eval_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        given an array of z coordinates, returns the xyz array of coordinates along the insertion</span>
<span class="sd">        :param z: n by 1 or numpy array containing z-coordinates</span>
<span class="sd">        :return: n by 3 numpy array containing xyz-coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trajectory.project"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.project">[docs]</a>    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        projects a point onto the trajectory line</span>
<span class="sd">        :param point: np.array(x, y, z) coordinates</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html</span>
        <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span> <span class="o">/</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span></div>

<div class="viewcode-block" id="Trajectory.mindist"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.mindist">[docs]</a>    <span class="k">def</span> <span class="nf">mindist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the minimum distance to the trajectory line for one or a set of points.</span>
<span class="sd">        If bounds are provided, computes the minimum distance to the segment instead of an</span>
<span class="sd">        infinite line.</span>
<span class="sd">        :param xyz: [..., 3]</span>
<span class="sd">        :param bounds: defaults to None.  np.array [2, 3]: segment boundaries, inf line if None</span>
<span class="sd">        :return: minimum distance [...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">proj</span> <span class="o">-</span> <span class="n">xyz</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># project the boundaries and the points along the traj</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>
            <span class="n">ob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="c1"># for points below and above boundaries, compute cartesian distance to the boundary</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">imin</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">xyz</span><span class="p">[</span><span class="n">imin</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="n">ob</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">imax</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">xyz</span><span class="p">[</span><span class="n">imax</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="n">ob</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span></div>

    <span class="k">def</span> <span class="nf">_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="c1"># uses symmetric form of 3d line equation to get xyz coordinates given one coordinate</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="c1"># there are cases where it&#39;s impossible to project if a line is // to the axis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">point</span>

<div class="viewcode-block" id="Trajectory.exit_points"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Trajectory.exit_points">[docs]</a>    <span class="k">def</span> <span class="nf">exit_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Trajectory and a BrainCoordinates object, computes the intersection of the</span>
<span class="sd">        trajectory with the brain coordinates bounding box</span>
<span class="sd">        :param bc: BrainCoordinate objects</span>
<span class="sd">        :return: np.ndarray 2 y 3 corresponding to exit points xyz coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">]</span>
        <span class="n">epoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_x</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">xlim</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_y</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">ylim</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_z</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">)]</span>
        <span class="n">epoints</span> <span class="o">=</span> <span class="n">epoints</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">epoints</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="n">epoints</span><span class="p">,</span> <span class="n">epoints</span> <span class="o">&lt;=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">epoints</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:]</span></div></div>


<div class="viewcode-block" id="Insertion"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Insertion">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Insertion</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines an ephys probe insertion in 3D coordinate. IBL conventions.</span>
<span class="sd">    To instantiate, use the static methods:</span>
<span class="sd">    Insertion.from_track</span>
<span class="sd">    Insertion.from_dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">phi</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="Insertion.from_track"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Insertion.from_track">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_track</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param brain_atlas: None. If provided, disregards the z coordinate and locks the insertion</span>
<span class="sd">        point to the z of the brain surface</span>
<span class="sd">        :return: Trajectory object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="s1">&#39;Input argument brain_atlas must be defined&#39;</span>
        <span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">xyzs</span><span class="p">)</span>
        <span class="c1"># project the deepest point into the vector to get the tip coordinate</span>
        <span class="n">tip</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">xyzs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">xyzs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]),</span> <span class="p">:])</span>
        <span class="c1"># get intersection with the brain surface as an entry point</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="n">Insertion</span><span class="o">.</span><span class="n">get_brain_entry</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">)</span>
        <span class="c1"># convert to spherical system to store the insertion</span>
        <span class="n">depth</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">cart2sph</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">entry</span> <span class="o">-</span> <span class="n">tip</span><span class="p">))</span>
        <span class="n">insertion_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                          <span class="s1">&#39;phi&#39;</span><span class="p">:</span> <span class="n">phi</span><span class="p">,</span> <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="n">theta</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">:</span> <span class="n">depth</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">Insertion</span><span class="p">(</span><span class="o">**</span><span class="n">insertion_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="Insertion.from_dict"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Insertion.from_dict">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs an Insertion object from the json information stored in probes.description file</span>
<span class="sd">        :param trj: dictionary containing at least the following keys, in um</span>
<span class="sd">           {</span>
<span class="sd">            &#39;x&#39;: 544.0,</span>
<span class="sd">            &#39;y&#39;: 1285.0,</span>
<span class="sd">            &#39;z&#39;: 0.0,</span>
<span class="sd">            &#39;phi&#39;: 0.0,</span>
<span class="sd">            &#39;theta&#39;: 5.0,</span>
<span class="sd">            &#39;depth&#39;: 4501.0</span>
<span class="sd">            }</span>
<span class="sd">        :param brain_atlas: None. If provided, disregards the z coordinate and locks the insertion</span>
<span class="sd">        point to the z of the brain surface</span>
<span class="sd">        :return: Trajectory object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span>
        <span class="k">if</span> <span class="n">brain_atlas</span><span class="p">:</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">y2i</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">)</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">x2i</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">top</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Insertion</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span>
                         <span class="n">phi</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">],</span> <span class="n">theta</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">],</span> <span class="n">depth</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">,</span>
                         <span class="n">beta</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;beta&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the trajectory object matching insertion coordinates</span>
<span class="sd">        :return: atlas.Trajectory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tip</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sph2cart</span><span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_surface_intersection</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Trajectory and a BrainAtlas object, computes the intersection of the trajectory</span>
<span class="sd">        and a surface (usually brain_atlas.top)</span>
<span class="sd">        :param brain_atlas:</span>
<span class="sd">        :param surface: np.array 2d, shape [ny, nx]</span>
<span class="sd">        :param z: init position for the lookup</span>
<span class="sd">        :return: 3 element array x,y,z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># do a recursive look-up of the brain surface along the trajectory, 5 is more than enough</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">eval_z</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">iy</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">y2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">x2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">surface</span><span class="p">[</span><span class="n">iy</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">xyz</span>

<div class="viewcode-block" id="Insertion.get_brain_exit"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Insertion.get_brain_exit">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_brain_exit</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Trajectory and a BrainAtlas object, computes the brain entry coordinate as the</span>
<span class="sd">        intersection of the trajectory and the brain surface (brain_atlas.top)</span>
<span class="sd">        :param brain_atlas:</span>
<span class="sd">        :return: 3 element array x,y,z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># do a recursive look-up of the brain surface along the trajectory, 5 is more than enough</span>
        <span class="k">return</span> <span class="n">Insertion</span><span class="o">.</span><span class="n">_get_surface_intersection</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">,</span>
                                                   <span class="n">brain_atlas</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">brain_atlas</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">zlim</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Insertion.get_brain_entry"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.Insertion.get_brain_entry">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_brain_entry</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a Trajectory and a BrainAtlas object, computes the brain entry coordinate as the</span>
<span class="sd">        intersection of the trajectory and the brain surface (brain_atlas.top)</span>
<span class="sd">        :param brain_atlas:</span>
<span class="sd">        :return: 3 element array x,y,z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># do a recursive look-up of the brain surface along the trajectory, 5 is more than enough</span>
        <span class="k">return</span> <span class="n">Insertion</span><span class="o">.</span><span class="n">_get_surface_intersection</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="p">,</span> <span class="n">brain_atlas</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BrainRegions"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainRegions">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">BrainRegions</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    self.id: contains label ids found in the BrainCoordinate.label volume</span>
<span class="sd">    self.name: list/tuple of brain region names</span>
<span class="sd">    self.acronym: list/tuple of brain region acronyms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">id</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">object</span>
    <span class="n">acronym</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">object</span>
    <span class="n">rgb</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
    <span class="n">level</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">parent</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

<div class="viewcode-block" id="BrainRegions.get"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainRegions.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bunch</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a bunch of the name/id</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uid</span><span class="p">,</span> <span class="n">uind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">iself</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dataclass_fields__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="n">iself</span><span class="p">[</span><span class="n">uind</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">b</span></div>

    <span class="k">def</span> <span class="nf">_navigate_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;down&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method to navigate the tree and get all related objects either up or down</span>
<span class="sd">        :param ids:</span>
<span class="sd">        :param direction:</span>
<span class="sd">        :return: Bunch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">ismember</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">ids</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;down&#39;</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">|=</span> <span class="n">ismember</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">indices</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">|=</span> <span class="n">ismember</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">indices</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;direction should be either &#39;up&#39; or &#39;down&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>  <span class="c1"># last iteration didn&#39;t find any match</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>

<div class="viewcode-block" id="BrainRegions.descendants"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainRegions.descendants">[docs]</a>    <span class="k">def</span> <span class="nf">descendants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get descendants from one or an array of ids</span>
<span class="sd">        :param ids: np.array or scalar representing the region primary key</span>
<span class="sd">        :return: Bunch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_navigate_tree</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;down&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrainRegions.ancestors"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.BrainRegions.ancestors">[docs]</a>    <span class="k">def</span> <span class="nf">ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get ancestors from one or an array of ids</span>
<span class="sd">        :param ids: np.array or scalar representing the region primary key</span>
<span class="sd">        :return: Bunch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_navigate_tree</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AllenAtlas"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.AllenAtlas">[docs]</a><span class="k">class</span> <span class="nc">AllenAtlas</span><span class="p">(</span><span class="n">BrainAtlas</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instantiates an atlas.BrainAtlas corresponding to the Allen CCF at the given resolution</span>
<span class="sd">    using the IBL Bregma and coordinate system</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res_um</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">mock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">hist_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param res_um: 10, 25 or 50 um</span>
<span class="sd">        :param par: dictionary of parameters to override systems ones</span>
<span class="sd">        :param scaling:</span>
<span class="sd">        :param mock:</span>
<span class="sd">        :return: atlas.BrainAtlas</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">par</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;one_params&#39;</span><span class="p">)</span>
        <span class="n">FLAT_IRON_ATLAS_REL_PATH</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;histology&#39;</span><span class="p">,</span> <span class="s1">&#39;ATLAS&#39;</span><span class="p">,</span> <span class="s1">&#39;Needles&#39;</span><span class="p">,</span> <span class="s1">&#39;Allen&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mock</span><span class="p">:</span>
            <span class="n">image</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">528</span><span class="p">,</span> <span class="mi">456</span><span class="p">,</span> <span class="mi">320</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">path_atlas</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">CACHE_DIR</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">FLAT_IRON_ATLAS_REL_PATH</span><span class="p">)</span>
            <span class="n">file_image</span> <span class="o">=</span> <span class="n">hist_path</span> <span class="ow">or</span> <span class="n">path_atlas</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;average_template_</span><span class="si">{</span><span class="n">res_um</span><span class="si">}</span><span class="s1">.nrrd&#39;</span><span class="p">)</span>
            <span class="n">file_label</span> <span class="o">=</span> <span class="n">path_atlas</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;annotation_</span><span class="si">{</span><span class="n">res_um</span><span class="si">}</span><span class="s1">.nrrd&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_image</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">file_image</span> <span class="o">=</span> <span class="n">path_atlas</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;average_template_</span><span class="si">{</span><span class="n">res_um</span><span class="si">}</span><span class="s1">.npz&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_label</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">file_label</span> <span class="o">=</span> <span class="n">path_atlas</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;annotation_</span><span class="si">{</span><span class="n">res_um</span><span class="si">}</span><span class="s1">.npz&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_image</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">_download_atlas_flatiron</span><span class="p">(</span><span class="n">file_image</span><span class="p">,</span> <span class="n">FLAT_IRON_ATLAS_REL_PATH</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_label</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">_download_atlas_flatiron</span><span class="p">(</span><span class="n">file_label</span><span class="p">,</span> <span class="n">FLAT_IRON_ATLAS_REL_PATH</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span>
            <span class="c1"># loads the files</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_volume</span><span class="p">(</span><span class="n">file_image</span><span class="p">)</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_volume</span><span class="p">(</span><span class="n">file_label</span><span class="p">)</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="n">regions_from_allen_csv</span><span class="p">(</span><span class="n">FILE_REGIONS</span><span class="p">)</span>
        <span class="n">xyz2dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># this is the c-contiguous ordering</span>
        <span class="n">dims2xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">dxyz</span> <span class="o">=</span> <span class="n">res_um</span> <span class="o">*</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">scaling</span>
        <span class="c1"># we use Bregma as the origin</span>
        <span class="n">ibregma</span> <span class="o">=</span> <span class="p">(</span><span class="n">ALLEN_CCF_LANDMARKS_MLAPDV_UM</span><span class="p">[</span><span class="s1">&#39;bregma&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">res_um</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_um</span> <span class="o">=</span> <span class="n">res_um</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">dxyz</span><span class="p">,</span> <span class="n">regions</span><span class="p">,</span> <span class="n">ibregma</span><span class="p">,</span>
                         <span class="n">dims2xyz</span><span class="o">=</span><span class="n">dims2xyz</span><span class="p">,</span> <span class="n">xyz2dims</span><span class="o">=</span><span class="n">xyz2dims</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_volume</span><span class="p">(</span><span class="n">file_volume</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">file_volume</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.nrrd&#39;</span><span class="p">:</span>
            <span class="n">volume</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nrrd</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file_volume</span><span class="p">,</span> <span class="n">index_order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>  <span class="c1"># ml, dv, ap</span>
            <span class="c1"># we want the coronal slice to be the most contiguous</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># image[iap, iml, idv]</span>
        <span class="k">elif</span> <span class="n">file_volume</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.npz&#39;</span><span class="p">:</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_volume</span><span class="p">)[</span><span class="s1">&#39;arr_0&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">volume</span>

<div class="viewcode-block" id="AllenAtlas.xyz2ccf"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.AllenAtlas.xyz2ccf">[docs]</a>    <span class="k">def</span> <span class="nf">xyz2ccf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">ccf_order</span><span class="o">=</span><span class="s1">&#39;mlapdv&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts coordinates to the CCF coordinates, which is assumed to be the cube indices</span>
<span class="sd">        times the spacing.</span>
<span class="sd">        :param xyz: mlapdv coordinates in um, origin Bregma</span>
<span class="sd">        :param ccf_order: &#39;mlapdv&#39; (ibl) or &#39;apdvml&#39; (Allen mcc vertices)</span>
<span class="sd">        :return: coordinates in um (mlapdv by default), origin is the front left top corner</span>
<span class="sd">         of the data volume</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ordre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ccf_order</span><span class="p">(</span><span class="n">ccf_order</span><span class="p">)</span>
        <span class="n">ccf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">xyz2i</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_um</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ccf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ordre</span><span class="p">]</span></div>

<div class="viewcode-block" id="AllenAtlas.ccf2xyz"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.AllenAtlas.ccf2xyz">[docs]</a>    <span class="k">def</span> <span class="nf">ccf2xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ccf</span><span class="p">,</span> <span class="n">ccf_order</span><span class="o">=</span><span class="s1">&#39;mlapdv&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts coordinates from the CCF coordinates, which is assumed to be the cube indices</span>
<span class="sd">        times the spacing.</span>
<span class="sd">        :param mlapdv coordinates in um, origin is the front left top corner of the data volume</span>
<span class="sd">        :param ccf_order: &#39;mlapdv&#39; (ibl) or &#39;apdvml&#39; (Allen mcc vertices)</span>
<span class="sd">        :return: xyz: mlapdv coordinates in um, origin Bregma</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ordre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ccf_order</span><span class="p">(</span><span class="n">ccf_order</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">i2xyz</span><span class="p">((</span><span class="n">ccf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ordre</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_um</span><span class="p">)))</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_ccf_order</span><span class="p">(</span><span class="n">ccf_order</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ccf_order</span> <span class="o">==</span> <span class="s1">&#39;mlapdv&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ccf_order</span> <span class="o">==</span> <span class="s1">&#39;apdvml&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ccf_order needs to be either &#39;mlapdv&#39; or &#39;apdvml&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="NeedlesAtlas"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.NeedlesAtlas">[docs]</a><span class="k">def</span> <span class="nf">NeedlesAtlas</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instantiates an atlas.BrainAtlas corresponding to the Allen CCF at the given resolution</span>
<span class="sd">    using the IBL Bregma and coordinate system. The Needles atlas defines a stretch along AP</span>
<span class="sd">    axis and a sqeeze along the DV axis.</span>
<span class="sd">    :param res_um: 10, 25 or 50 um</span>
<span class="sd">    :return: atlas.BrainAtlas</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DV_SCALE</span> <span class="o">=</span> <span class="mf">0.952</span>  <span class="c1"># multiplicative factor on DV dimension, determined from MRI-&gt;CCF transform</span>
    <span class="n">AP_SCALE</span> <span class="o">=</span> <span class="mf">1.087</span>  <span class="c1"># multiplicative factor on AP dimension</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;scaling&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">AP_SCALE</span><span class="p">,</span> <span class="n">DV_SCALE</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">AllenAtlas</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_download_atlas_flatiron</span><span class="p">(</span><span class="n">file_image</span><span class="p">,</span> <span class="n">FLAT_IRON_ATLAS_REL_PATH</span><span class="p">,</span> <span class="n">par</span><span class="p">):</span>
    <span class="n">file_image</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">url</span> <span class="o">=</span> <span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">HTTP_DATA_SERVER</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span>
           <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">FLAT_IRON_ATLAS_REL_PATH</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">file_image</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="n">http_download_file</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">cache_dir</span><span class="o">=</span><span class="n">Path</span><span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">CACHE_DIR</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="n">FLAT_IRON_ATLAS_REL_PATH</span><span class="p">),</span>
                       <span class="n">username</span><span class="o">=</span><span class="n">par</span><span class="o">.</span><span class="n">HTTP_DATA_SERVER_LOGIN</span><span class="p">,</span>
                       <span class="n">password</span><span class="o">=</span><span class="n">par</span><span class="o">.</span><span class="n">HTTP_DATA_SERVER_PWD</span><span class="p">)</span>


<div class="viewcode-block" id="regions_from_allen_csv"><a class="viewcode-back" href="../../../_autosummary/ibllib.atlas.atlas.html#ibllib.atlas.atlas.regions_from_allen_csv">[docs]</a><span class="k">def</span> <span class="nf">regions_from_allen_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="o">=</span><span class="n">FILE_REGIONS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads csv file containing the ALlen Ontology and instantiates a BrainRegions object</span>
<span class="sd">    :param csv_file:</span>
<span class="sd">    :return: BrainRegions object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df_regions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>
    <span class="c1"># converts colors to RGB uint8 array</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">df_regions</span><span class="o">.</span><span class="n">color_hex_triplet</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="mi">256</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="p">(</span><span class="n">df_regions</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">4</span><span class="p">))[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># creates the BrainRegion instance</span>
    <span class="k">return</span> <span class="n">BrainRegions</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">df_regions</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">df_regions</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                        <span class="n">acronym</span><span class="o">=</span><span class="n">df_regions</span><span class="o">.</span><span class="n">acronym</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                        <span class="n">rgb</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                        <span class="n">level</span><span class="o">=</span><span class="n">df_regions</span><span class="o">.</span><span class="n">depth</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                        <span class="n">parent</span><span class="o">=</span><span class="n">df_regions</span><span class="o">.</span><span class="n">parent_structure_id</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, International Brain Laboratory

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>