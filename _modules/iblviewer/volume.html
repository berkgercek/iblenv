

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>iblviewer.volume &mdash; IBL Library  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/style.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> IBL Library
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../01_overview.html">IBL data structure</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../02_installation.html">Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../03_one.html">ONE</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../04_alf.html">Alyx Files (ALF)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../05_datajoint.html">Datajoint</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../07_tutorials.html">Tutorials</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../06_examples.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../08_public.html">IBL Public Data</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../011_ibl_viewer.html">IBL Viewer</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../09_contribution.html">Contribution Statement</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../010_api_reference.html">API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">IBL Library</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>iblviewer.volume</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for iblviewer.volume</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="kn">import</span> <span class="nn">nrrd</span>
<span class="kn">import</span> <span class="nn">vtk</span>
<span class="kn">import</span> <span class="nn">vedo</span>

<span class="kn">from</span> <span class="nn">iblviewer.collection</span> <span class="kn">import</span> <span class="n">Collection</span>
<span class="kn">import</span> <span class="nn">iblviewer.utils</span> <span class="k">as</span> <span class="nn">utils</span>


<div class="viewcode-block" id="VolumeModel"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeModel">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">VolumeModel</span><span class="p">:</span>
    <span class="n">RAW</span> <span class="o">=</span> <span class="s1">&#39;raw&#39;</span>
    <span class="n">SEGMENTED</span> <span class="o">=</span> <span class="s1">&#39;segmented&#39;</span>
    
    <span class="n">NORMALIZED_SUFFIX</span> <span class="o">=</span> <span class="s1">&#39;_norm&#39;</span>
    <span class="n">DATA_TYPE</span> <span class="o">=</span> <span class="p">{</span><span class="n">RAW</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="n">SEGMENTED</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
    <span class="n">PREFIX</span> <span class="o">=</span> <span class="s1">&#39;Volume&#39;</span>
    <span class="n">__count</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="VolumeModel.unique_name"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeModel.unique_name">[docs]</a>    <span class="k">def</span> <span class="nf">unique_name</span><span class="p">():</span>
        <span class="n">VolumeModel</span><span class="o">.</span><span class="n">__count</span> <span class="o">+=</span> <span class="mi">1</span> 
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">VolumeModel</span><span class="o">.</span><span class="n">PREFIX</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">VolumeModel</span><span class="o">.</span><span class="n">__count</span><span class="si">}</span><span class="s1">&#39;</span></div>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">unique_name</span><span class="p">)</span>
    <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">scalars</span><span class="p">:</span> <span class="n">Collection</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">Collection</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">data_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">data_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">data_map_step</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">data_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">RAW</span>
    <span class="n">resolution</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># Default units are microns.</span>
    <span class="n">units</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-06</span>
    <span class="n">base_color_map</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># At IBL, volume mappings are used from ibllib: ibllib.atlas.regions.mappings</span>
    <span class="n">mapping_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">lateralized</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Mapping function. If None, the volume will be given as it is.</span>
    <span class="n">mapping</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">luts</span><span class="p">:</span> <span class="n">Collection</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">Collection</span><span class="p">)</span>
    <span class="n">slicers</span><span class="p">:</span> <span class="n">Collection</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">Collection</span><span class="p">)</span>

    <span class="n">interactive_subsampling</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">volume_visible</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">slices_visible</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">transpose_shape</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">dimensions</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">center</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

<div class="viewcode-block" id="VolumeModel.compute_size"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeModel.compute_size">[docs]</a>    <span class="k">def</span> <span class="nf">compute_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute volume size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">)</span> <span class="c1"># TODO: move this to constructor or init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">/</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="VolumeModel.compute_range"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeModel.compute_range">[docs]</a>    <span class="k">def</span> <span class="nf">compute_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute min and max range in the volume</span>
<span class="sd">        :return: Min and max values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="c1">#print(&#39;Volume min-max&#39;, self.data_min, self.data_max)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_max</span></div>

<div class="viewcode-block" id="VolumeModel.guess_volume_type"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeModel.guess_volume_type">[docs]</a>    <span class="k">def</span> <span class="nf">guess_volume_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer the volume type when it was not specified by the user.</span>
<span class="sd">        We assume here that typical values between -1 and 1 are raw volumes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_min</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_range</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_min</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_max</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">guess</span> <span class="o">=</span> <span class="n">VolumeModel</span><span class="o">.</span><span class="n">RAW</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">guess</span> <span class="o">=</span> <span class="n">VolumeModel</span><span class="o">.</span><span class="n">SEGMENTED</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">=</span> <span class="n">guess</span></div>

<div class="viewcode-block" id="VolumeModel.is_segmented"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeModel.is_segmented">[docs]</a>    <span class="k">def</span> <span class="nf">is_segmented</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">auto_guess</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get whether current volume/image is segmented</span>
<span class="sd">        :return: Boolean</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">auto_guess</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">guess_volume_type</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="n">VolumeModel</span><span class="o">.</span><span class="n">SEGMENTED</span></div>

<div class="viewcode-block" id="VolumeModel.read_volume"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeModel.read_volume">[docs]</a>    <span class="k">def</span> <span class="nf">read_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read local volume. Downloads the file first if it&#39;s remote.</span>
<span class="sd">        :param file_path: Volume path</span>
<span class="sd">        :return: 3D array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">file_path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">file_path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ftp&#39;</span><span class="p">):</span>
            <span class="n">downloaded_temp_file_path</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">file_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;nrrd&#39;</span><span class="p">):</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="n">nrrd</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">downloaded_temp_file_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">loadImageData</span><span class="p">(</span><span class="n">downloaded_temp_file_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">file_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;nrrd&#39;</span><span class="p">):</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="n">nrrd</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">index_order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">loadImageData</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="VolumeModel.load_volume"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeModel.load_volume">[docs]</a>    <span class="k">def</span> <span class="nf">load_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">remap_scalars</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">make_current</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a volume data file. Supports NRRD and many other formats thanks to vedo/VTK</span>
<span class="sd">        :param file_path: Volume file path. Could support other file types easily.</span>
<span class="sd">        :param remap_scalars: Whether scalar values in the volume are replaced by </span>
<span class="sd">            their row id from a mapping that stores. This is necessary in the case of segmented</span>
<span class="sd">            volumes with regions that have a discontinuous id.</span>
<span class="sd">        :param mapping: Pandas Series or a Dictionary</span>
<span class="sd">        :param make_current: Set the volume data as the current one</span>
<span class="sd">        :return: 3D array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">remap_scalars</span> <span class="ow">or</span> <span class="n">mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">import_volume</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">new_file_path</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">change_file_name</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">VolumeModel</span><span class="o">.</span><span class="n">NORMALIZED_SUFFIX</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">new_file_path</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">import_volume</span><span class="p">(</span><span class="n">new_file_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">import_volume</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_slow</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">new_file_path</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Remapped scalar values in: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">time_diff</span><span class="p">(</span><span class="n">time</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            if volume is not None:</span>
<span class="sd">                logging.info(&#39;Opened atlas &#39; + new_file_path + &#39; in &#39; + str(utils.time_diff(time)) + &#39;s&#39;)</span>
<span class="sd">                min_value, max_value = np.amin(data), np.amax(data)</span>
<span class="sd">                logging.info(&#39;Min max scalar values in volume &#39; + str(min_value) + &#39; -&gt; &#39; + str(max_value))</span>
<span class="sd">            else:</span>
<span class="sd">                logging.error(&#39;Failed to open atlas &#39; + new_file_path)</span>
<span class="sd">            &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">make_current</span> <span class="ow">and</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">mapping</span></div>

<div class="viewcode-block" id="VolumeModel.transpose"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeModel.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transpose the volume for visualization in VTK</span>
<span class="sd">        :param shape: The new shape. If None, will default to self.transpose_shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose_shape</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeModel.remap_slow"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeModel.remap_slow">[docs]</a>    <span class="k">def</span> <span class="nf">remap_slow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">write_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reassign volume values (slow on large volumes!) so that they&#39;re continuous</span>
<span class="sd">        :param data: Volume ndarray</span>
<span class="sd">        :param write_path: Where the modified volume will be stored </span>
<span class="sd">            (to spare going through this method next time)</span>
<span class="sd">        :param mapping: Pandas Series or a Dictionary that maps raw volume scalars to new ones</span>
<span class="sd">        :return: Modified volume data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Building appropriate volume from Allen data source...&#39;</span><span class="p">)</span>
        <span class="c1">#volume = np.vectorize(self.f)(data)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="n">num_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Num regions labeled in volume &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_labels</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; from &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; in atlas&#39;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reassigning &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_labels</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; scalar values...&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iter_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_labels</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">iter_id</span><span class="p">]</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">mapping</span> <span class="o">==</span> <span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># On a large volume, this takes a long time</span>
            <span class="n">data</span><span class="p">[</span><span class="n">data</span> <span class="o">==</span> <span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">num_labels</span> <span class="o">&gt;</span> <span class="mi">10000</span> <span class="ow">and</span> <span class="n">iter_id</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;  Progress: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">iter_id</span><span class="o">/</span><span class="n">num_labels</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">write_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Saving volume data under &#39;</span> <span class="o">+</span> <span class="n">write_path</span><span class="p">)</span>
            <span class="n">nrrd</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">write_path</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">index_order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">mapping</span></div>
        
<div class="viewcode-block" id="VolumeModel.build_lut"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeModel.build_lut">[docs]</a>    <span class="k">def</span> <span class="nf">build_lut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalar_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scalar_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">alpha_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero_is_transparent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                    <span class="n">noise_amount</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">nan_rgba</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">make_active</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a look-up table (LUT, sometimes known as transfer function) for the volume</span>
<span class="sd">        :param scalar_map: A 2D list with values in first column from the volume itself and values from</span>
<span class="sd">            the second column being your scalar values that correspond to such region</span>
<span class="sd">        :param scalar_range: Min and max values in a list</span>
<span class="sd">        :param color_map: Color map name to apply</span>
<span class="sd">        :param alpha_map: Alpha map, either None or a list of values the same length as scalar_map, that</span>
<span class="sd">            says how transparent a scalar value should be</span>
<span class="sd">        :param zero_is_transparent: Whether zero values are made transparent, True by default</span>
<span class="sd">        :param noise_amount: Whether a noise value is applied on the colors</span>
<span class="sd">        :param nan_rgba: Color and transparency (RGBA) to assign to invalid (out of range or None) scalar values</span>
<span class="sd">        :param make_active: Whether this one is made active (you still have to update the views after that)</span>
<span class="sd">        :return: LUTModel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lut_model</span> <span class="o">=</span> <span class="n">LUTModel</span><span class="p">()</span>
        <span class="n">lut_model</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">scalar_map</span><span class="p">,</span> <span class="n">scalar_range</span><span class="p">,</span> <span class="n">color_map</span><span class="p">,</span> <span class="n">alpha_map</span><span class="p">,</span> 
                        <span class="n">zero_is_transparent</span><span class="p">,</span> <span class="n">noise_amount</span><span class="p">,</span> <span class="n">nan_rgba</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">luts</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">lut_model</span><span class="p">,</span> <span class="n">set_current</span><span class="o">=</span><span class="n">make_active</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lut_model</span></div></div>


<div class="viewcode-block" id="blend_maps"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.blend_maps">[docs]</a><span class="k">def</span> <span class="nf">blend_maps</span><span class="p">(</span><span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">total_time</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Blend color maps</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">weight1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">total_time</span> <span class="o">-</span> <span class="n">time</span><span class="p">)</span>
    <span class="n">weight2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">map1</span> <span class="o">*</span> <span class="n">weight1</span> <span class="o">+</span> <span class="n">map2</span> <span class="o">*</span> <span class="n">weight2</span></div>


<div class="viewcode-block" id="Volume"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.Volume">[docs]</a><span class="k">class</span> <span class="nc">Volume</span><span class="p">(</span><span class="n">vedo</span><span class="o">.</span><span class="n">Volume</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Overwriting of vedo.Volume constructor that is ill-designed as</span>
<span class="sd">    it transposes the given numpy array without us knowing about it,</span>
<span class="sd">    not giving us the option to choose about that.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">inputobj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">c</span><span class="o">=</span><span class="s1">&#39;RdBu_r&#39;</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
                 <span class="n">alphaGradient</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">alphaUnit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">shade</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">mapper</span><span class="o">=</span><span class="s1">&#39;smart&#39;</span><span class="p">):</span>

        <span class="n">vtk</span><span class="o">.</span><span class="n">vtkVolume</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">vedo</span><span class="o">.</span><span class="n">BaseGrid</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1">###################</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputobj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>

            <span class="k">if</span> <span class="s2">&quot;https://&quot;</span> <span class="ow">in</span> <span class="n">inputobj</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">vedo.io</span> <span class="kn">import</span> <span class="n">download</span>
                <span class="n">inputobj</span> <span class="o">=</span> <span class="n">download</span><span class="p">(</span><span class="n">inputobj</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># fpath</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">inputobj</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inputobj</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">inputobj</span><span class="p">))</span>

        <span class="c1">###################</span>
        <span class="k">if</span> <span class="s1">&#39;gpu&#39;</span> <span class="ow">in</span> <span class="n">mapper</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mapper</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkGPUVolumeRayCastMapper</span><span class="p">()</span>
        <span class="k">elif</span> <span class="s1">&#39;opengl_gpu&#39;</span> <span class="ow">in</span> <span class="n">mapper</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mapper</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkOpenGLGPUVolumeRayCastMapper</span><span class="p">()</span>
        <span class="k">elif</span> <span class="s1">&#39;smart&#39;</span> <span class="ow">in</span> <span class="n">mapper</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mapper</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkSmartVolumeMapper</span><span class="p">()</span>
        <span class="k">elif</span> <span class="s1">&#39;fixed&#39;</span> <span class="ow">in</span> <span class="n">mapper</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mapper</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkFixedPointVolumeRayCastMapper</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkMapper</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mapper</span> <span class="o">=</span> <span class="n">mapper</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error unknown mapper type&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">mapper</span><span class="p">])</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SetMapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mapper</span><span class="p">)</span>

        <span class="c1">###################</span>
        <span class="n">inputtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">inputobj</span><span class="p">))</span>
        <span class="c1">#colors.printc(&#39;Volume inputtype&#39;, inputtype)</span>

        <span class="k">if</span> <span class="n">inputobj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkImageData</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">vedo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">isSequence</span><span class="p">(</span><span class="n">inputobj</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputobj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span> <span class="c1"># scan sequence of BMP files</span>
                <span class="n">ima</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkImageAppend</span><span class="p">()</span>
                <span class="n">ima</span><span class="o">.</span><span class="n">SetAppendAxis</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">pb</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">ProgressBar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputobj</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pb</span><span class="o">.</span><span class="n">range</span><span class="p">():</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">inputobj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">picr</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkBMPReader</span><span class="p">()</span>
                    <span class="n">picr</span><span class="o">.</span><span class="n">SetFileName</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="n">picr</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
                    <span class="n">mgf</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkImageMagnitude</span><span class="p">()</span>
                    <span class="n">mgf</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="n">picr</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
                    <span class="n">mgf</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
                    <span class="n">ima</span><span class="o">.</span><span class="n">AddInputData</span><span class="p">(</span><span class="n">mgf</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
                    <span class="n">pb</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;loading...&#39;</span><span class="p">)</span>
                <span class="n">ima</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">ima</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;ndarray&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inputtype</span><span class="p">:</span>
                    <span class="n">inputobj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inputobj</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputobj</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">varr</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">numpy2vtk</span><span class="p">(</span><span class="n">inputobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># ------------------------------ Nasty lines commented here</span>
                    <span class="c1">#if len(inputobj.shape)&gt;2:</span>
                        <span class="c1">#inputobj = np.transpose(inputobj, axes=[2, 1, 0])</span>
                    <span class="n">varr</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">numpy2vtk</span><span class="p">(</span><span class="n">inputobj</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="n">varr</span><span class="o">.</span><span class="n">SetName</span><span class="p">(</span><span class="s1">&#39;input_scalars&#39;</span><span class="p">)</span>

                <span class="n">img</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkImageData</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">img</span><span class="o">.</span><span class="n">SetDimensions</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputobj</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">vedo</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">printc</span><span class="p">(</span><span class="s2">&quot;Error: must set dimensions (dims keyword) in Volume.&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span>
                    <span class="n">img</span><span class="o">.</span><span class="n">SetDimensions</span><span class="p">(</span><span class="n">inputobj</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">img</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">SetScalars</span><span class="p">(</span><span class="n">varr</span><span class="p">)</span>

                <span class="c1">#to convert rgb to numpy</span>
                <span class="c1">#        img_scalar = data.GetPointData().GetScalars()</span>
                <span class="c1">#        dims = data.GetDimensions()</span>
                <span class="c1">#        n_comp = img_scalar.GetNumberOfComponents()</span>
                <span class="c1">#        temp = utils.vtk2numpy(img_scalar)</span>
                <span class="c1">#        numpy_data = temp.reshape(dims[1],dims[0],n_comp)</span>
                <span class="c1">#        numpy_data = numpy_data.transpose(0,1,2)</span>
                <span class="c1">#        numpy_data = np.flipud(numpy_data)</span>

        <span class="k">elif</span> <span class="s2">&quot;ImageData&quot;</span> <span class="ow">in</span> <span class="n">inputtype</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">inputobj</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputobj</span><span class="p">,</span> <span class="n">vedo</span><span class="o">.</span><span class="n">Volume</span><span class="p">):</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">inputobj</span><span class="o">.</span><span class="n">inputdata</span><span class="p">()</span>

        <span class="k">elif</span> <span class="s2">&quot;UniformGrid&quot;</span> <span class="ow">in</span> <span class="n">inputtype</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">inputobj</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inputobj</span><span class="p">,</span> <span class="s2">&quot;GetOutput&quot;</span><span class="p">):</span> <span class="c1"># passing vtk object, try extract imagdedata</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inputobj</span><span class="p">,</span> <span class="s2">&quot;Update&quot;</span><span class="p">):</span>
                <span class="n">inputobj</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">inputobj</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputobj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">vedo.io</span> <span class="kn">import</span> <span class="n">loadImageData</span><span class="p">,</span> <span class="n">download</span>
            <span class="k">if</span> <span class="s2">&quot;https://&quot;</span> <span class="ow">in</span> <span class="n">inputobj</span><span class="p">:</span>
                <span class="n">inputobj</span> <span class="o">=</span> <span class="n">download</span><span class="p">(</span><span class="n">inputobj</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">loadImageData</span><span class="p">(</span><span class="n">inputobj</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">vedo</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">printc</span><span class="p">(</span><span class="s2">&quot;Volume(): cannot understand input type:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">inputtype</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">img</span><span class="o">.</span><span class="n">SetDimensions</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">img</span><span class="o">.</span><span class="n">SetOrigin</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span> <span class="c1">### DIFFERENT from volume.origin()!</span>

        <span class="k">if</span> <span class="n">spacing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">img</span><span class="o">.</span><span class="n">SetSpacing</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">img</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span><span class="o">.</span><span class="n">color</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">alphaGradient</span><span class="p">(</span><span class="n">alphaGradient</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GetProperty</span><span class="p">()</span><span class="o">.</span><span class="n">SetShade</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GetProperty</span><span class="p">()</span><span class="o">.</span><span class="n">SetInterpolationType</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GetProperty</span><span class="p">()</span><span class="o">.</span><span class="n">SetScalarOpacityUnitDistance</span><span class="p">(</span><span class="n">alphaUnit</span><span class="p">)</span>

        <span class="c1"># remember stuff:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_color</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alphaGrad</span> <span class="o">=</span> <span class="n">alphaGradient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alphaUnit</span> <span class="o">=</span> <span class="n">alphaUnit</span></div>


<div class="viewcode-block" id="LUTModel"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.LUTModel">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">LUTModel</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class might look slightly convoluted but it&#39;s actually simple.</span>

<span class="sd">    We use double mapping here in order to enable live/interactive visualization</span>
<span class="sd">    of volumetric data. Instead of replacing values in a 3D volume, we only replace</span>
<span class="sd">    the colors in the 1D LUT list.</span>
<span class="sd">    </span>
<span class="sd">    The point is that it&#39;s too slow to update a given data, like a segmented</span>
<span class="sd">    volume with custom values. Instead, we map such custom values to a 1D</span>
<span class="sd">    array (our LUT) that maps colors to raw volume values.</span>
<span class="sd">    </span>
<span class="sd">    This is much faster in terms of rendering and it enables interactive visualization.</span>
<span class="sd">    The scalar_lut is the original LUT for the given scalars (custom values)</span>
<span class="sd">    and the mapped_lut is the LUT assigned to the surfaces (like slices)</span>
<span class="sd">    that have copied data from the volume. The volume is given color_map </span>
<span class="sd">    and alpha_map through vedo methods.</span>

<span class="sd">    You might say &quot;ok for double mapping, it&#39;s the only way for interactive</span>
<span class="sd">    rendering of a volume, but what about color_map and mapped_lut? Aren&#39;t</span>
<span class="sd">    they the same?&quot;. The answer is: they&#39;re the same but VTK does not accept</span>
<span class="sd">    a vtkLookupTable for a volume. Instead, it wants a vtkColorTransferFunction</span>
<span class="sd">    and a vtkPiecewiseFunction for alpha. There&#39;s no way around it.</span>
<span class="sd">    The color_map will be computed as a vtkColorTransferFunction and</span>
<span class="sd">    the alpha_map as the vtkPiecewiseFunction.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="ne">NotImplementedError</span>

    <span class="n">color_map_function</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">scalar_map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">scalar_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">scalar_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">scalar_lut</span><span class="p">:</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkLookupTable</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mapped_lut</span><span class="p">:</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkLookupTable</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="n">color_map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">alpha_map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">base_color_map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="LUTModel.build"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.LUTModel.build">[docs]</a>    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalar_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scalar_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="n">alpha_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero_is_transparent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                    <span class="n">noise_amount</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">nan_rgba</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">make_active</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a look-up table (LUT, sometimes known as transfer function) for the volume</span>
<span class="sd">        :param scalar_map: A 2D list with values in first column from the volume itself and values from</span>
<span class="sd">            the second column being your scalar values that correspond to such region</span>
<span class="sd">        :param scalar_range: Min and max values in a list</span>
<span class="sd">        :param color_map: Color map name to apply</span>
<span class="sd">        :param alpha_map: Alpha map, either None or a list of values the same length as scalar_map, that</span>
<span class="sd">            says how transparent a scalar value should be</span>
<span class="sd">        :param zero_is_transparent: Whether zero values are made transparent, True by default</span>
<span class="sd">        :param noise_amount: Whether a noise value is applied on the colors</span>
<span class="sd">        :param nan_rgba: Color and transparency (RGBA) to assign to invalid (out of range or None) scalar values</span>
<span class="sd">        :param make_active: Whether this one is made active (you still have to update the views after that)</span>
<span class="sd">        :return: LUTModel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">color_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">nan_rgba</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nan_rgba</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_color_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_color_map</span> <span class="o">=</span> <span class="n">color_map</span>
        
        <span class="c1"># 10 is a test, this means we&#39;d have 10 colors between 0.0 and 1.0, and also 10 colors between 0.0 and 9.8</span>
        <span class="n">min_steps</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="c1">#num_volume_scalars = min_steps if scalar_map is None else len(scalar_map)</span>
        <span class="c1">#num_regions = self.get_num_regions()</span>

        <span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">alphas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkLookupTable</span><span class="p">()</span>
        <span class="n">scalar_lut</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkLookupTable</span><span class="p">()</span>

        <span class="c1"># Use the number of values in the volume</span>
        <span class="n">num_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_color_map</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_color_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">color_map</span><span class="p">)</span>
        <span class="n">num_steps</span> <span class="o">=</span> <span class="mi">2655</span>
        <span class="n">s_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">s_max</span> <span class="o">=</span> <span class="n">num_steps</span>
        <span class="k">if</span> <span class="n">scalar_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">color_map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_color_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">color_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_color_map</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            target = color_map</span>
<span class="sd">        else:</span>
<span class="sd">            target = scalar_map</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#loop = sort(list(target.keys())) if isinstance(target, dict) else range(num_steps)</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">noise_amount</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">noise_amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">num_steps</span><span class="p">)</span> <span class="o">*</span> <span class="n">noise_amount</span> <span class="o">-</span> <span class="n">noise_amount</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># Vedo works with nested lists: </span>
        <span class="c1"># [region_id, [r, g, b]] for color, and [region_id, a] for alpha</span>
        <span class="k">if</span> <span class="n">scalar_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#scalar_map = np.arange(len(color_map))</span>
            <span class="n">lut</span><span class="o">.</span><span class="n">SetRange</span><span class="p">(</span><span class="n">s_min</span><span class="p">,</span> <span class="n">s_max</span><span class="p">)</span>
            <span class="n">lut</span><span class="o">.</span><span class="n">SetNumberOfTableValues</span><span class="p">(</span><span class="n">num_steps</span><span class="p">)</span>
            <span class="n">scalar_lut</span><span class="o">.</span><span class="n">SetRange</span><span class="p">(</span><span class="n">s_min</span><span class="p">,</span> <span class="n">s_max</span><span class="p">)</span>
            <span class="n">scalar_lut</span><span class="o">.</span><span class="n">SetNumberOfTableValues</span><span class="p">(</span><span class="n">num_steps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r_id</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">getColor</span><span class="p">(</span><span class="n">color_map</span><span class="p">[</span><span class="n">r_id</span><span class="p">])</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">color</span> <span class="o">+</span> <span class="n">noise</span><span class="p">[</span><span class="n">r_id</span><span class="p">]</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">r_id</span><span class="p">,</span> <span class="n">color</span><span class="p">])</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">alpha_map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">alpha_map</span><span class="p">[</span><span class="n">r_id</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">r_id</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">zero_is_transparent</span><span class="p">:</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">alphas</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">r_id</span><span class="p">,</span> <span class="n">alpha</span><span class="p">])</span>
                <span class="n">lut</span><span class="o">.</span><span class="n">SetTableValue</span><span class="p">(</span><span class="n">r_id</span><span class="p">,</span> <span class="o">*</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
                <span class="n">scalar_lut</span><span class="o">.</span><span class="n">SetTableValue</span><span class="p">(</span><span class="n">r_id</span><span class="p">,</span> <span class="o">*</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
                <span class="c1">#scalar_map[r_id] = color_map[r_id]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s_min</span><span class="p">,</span> <span class="n">s_max</span> <span class="o">=</span> <span class="n">scalar_range</span>
            <span class="n">lut</span><span class="o">.</span><span class="n">SetRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">)</span>
            <span class="n">lut</span><span class="o">.</span><span class="n">SetNumberOfTableValues</span><span class="p">(</span><span class="n">num_steps</span><span class="p">)</span>
            <span class="n">color</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">r_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">scalar_map</span><span class="p">[</span><span class="n">r_id</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span><span class="c1"># or s_min &gt; value or s_max &lt; value:</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">nan_rgba</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="n">nan_rgba</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">colorMap</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">color_map</span><span class="p">,</span> <span class="n">s_min</span><span class="p">,</span> <span class="n">s_max</span><span class="p">)</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">alpha_map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">alpha_map</span><span class="p">[</span><span class="n">r_id</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">zero_is_transparent</span><span class="p">:</span>
                        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">colors</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">r_id</span><span class="p">,</span> <span class="n">color</span><span class="p">])</span>
                <span class="n">alphas</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">r_id</span><span class="p">,</span> <span class="n">alpha</span><span class="p">])</span>
                <span class="n">lut</span><span class="o">.</span><span class="n">SetTableValue</span><span class="p">(</span><span class="n">r_id</span><span class="p">,</span> <span class="o">*</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
                
            <span class="c1"># Real scalar LUT, mainly as a reference for the user</span>
            <span class="n">mock_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">s_min</span><span class="p">,</span> <span class="n">s_max</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">)</span>
            <span class="n">scalar_lut</span><span class="o">.</span><span class="n">SetRange</span><span class="p">(</span><span class="n">s_min</span><span class="p">,</span> <span class="n">s_max</span><span class="p">)</span>
            <span class="n">scalar_lut</span><span class="o">.</span><span class="n">SetNumberOfTableValues</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mock_values</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">r_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mock_values</span><span class="p">)):</span>
                <span class="n">color</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vedo</span><span class="o">.</span><span class="n">colorMap</span><span class="p">(</span><span class="n">mock_values</span><span class="p">[</span><span class="n">r_id</span><span class="p">],</span> <span class="n">color_map</span><span class="p">,</span> <span class="n">s_min</span><span class="p">,</span> <span class="n">s_max</span><span class="p">))</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">mock_values</span><span class="p">[</span><span class="n">r_id</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">zero_is_transparent</span> <span class="k">else</span> <span class="mf">1.0</span>
                <span class="n">scalar_lut</span><span class="o">.</span><span class="n">SetTableValue</span><span class="p">(</span><span class="n">r_id</span><span class="p">,</span> <span class="o">*</span><span class="n">color</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="c1">#colors = np.array(colors, dtype=object)</span>
        <span class="c1">#alphas = np.array(alphas)</span>
        <span class="n">lut</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>
        <span class="n">scalar_lut</span><span class="o">.</span><span class="n">Build</span><span class="p">()</span>

        <span class="c1"># Just to avoid confusion: the user can give a string as a color map, like &#39;viridis&#39;</span>
        <span class="c1"># but the real color map object is stored in self.color_map. The name &#39;viridis&#39;</span>
        <span class="c1"># is stored under self.color_map_function (if needed later on)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_map_function</span> <span class="o">=</span> <span class="n">color_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_map</span> <span class="o">=</span> <span class="n">colors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_map</span> <span class="o">=</span> <span class="n">alphas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalar_map</span> <span class="o">=</span> <span class="n">scalar_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapped_lut</span> <span class="o">=</span> <span class="n">lut</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalar_lut</span> <span class="o">=</span> <span class="n">scalar_lut</span></div>

<div class="viewcode-block" id="LUTModel.get_sorted_scalars"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.LUTModel.get_sorted_scalars">[docs]</a>    <span class="k">def</span> <span class="nf">get_sorted_scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a numpy 2D array of key-value pairs sorted by value</span>
<span class="sd">        :return: 2D array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sorted_scalars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scalar_map</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scalar_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scalar_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">sorted_scalars</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">keys</span>
        <span class="n">sorted_scalars</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="n">sorted_mask</span> <span class="o">=</span> <span class="n">sorted_scalars</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
        <span class="n">sorted_scalars</span> <span class="o">=</span> <span class="n">sorted_scalars</span><span class="p">[</span><span class="n">sorted_mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sorted_scalars</span></div></div>



<div class="viewcode-block" id="VolumeController"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController">[docs]</a><span class="k">class</span> <span class="nc">VolumeController</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper class that handles both the volume and its slices</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">initialize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clipping</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">slicer_box</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">center_on_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">alpha_unit_upper_offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">add_to_scene</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>
<span class="sd">        :param plot: Plot instance</span>
<span class="sd">        :param model: VolumeModel instance</span>
<span class="sd">        :param initialize: Whether the initalization</span>
<span class="sd">        :param clipping: Whether clipping is enabled at init time</span>
<span class="sd">        :param slicer_box: Whether the slicer box is enabled at init</span>
<span class="sd">        :param center_on_edges: Whether the volume is offest by half a voxel or not</span>
<span class="sd">        :param alpha_unit_upper_offset: The offset to apply to alpha unit computation.</span>
<span class="sd">            If greater than 0, the volume will be less opaque</span>
<span class="sd">        :param add_to_scene: Whether the volume is added to scene after init</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">picker</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isosurfaces</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounding_mesh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_unit_upper_offset</span> <span class="o">=</span> <span class="n">alpha_unit_upper_offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_factor</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="c1"># * self.model.resolution</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clipping_planes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enable_volume_clipping</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clipping_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slicers_selectable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalar_bar</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">if</span> <span class="n">initialize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">clipping</span><span class="p">,</span> <span class="n">slicer_box</span><span class="p">,</span> <span class="n">center_on_edges</span><span class="p">,</span> <span class="n">add_to_scene</span><span class="p">)</span>
        <span class="c1">#msg = &#39;Volume abs center&#39;, self.volume_center, &#39;position&#39;, np.array(self.volume_actor.pos())</span>
        <span class="c1">#logging.info(msg)</span>

<div class="viewcode-block" id="VolumeController.get_related_actors"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.get_related_actors">[docs]</a>    <span class="k">def</span> <span class="nf">get_related_actors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all 3D actors related to this view (for registering it in the application)</span>
<span class="sd">        :return: List of VTK objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">actors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">slicer_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">:</span>
            <span class="n">actor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">[</span><span class="n">slicer_id</span><span class="p">]</span><span class="o">.</span><span class="n">actor</span>
            <span class="k">if</span> <span class="n">actor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">actors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">actor</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iso_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">isosurfaces</span><span class="p">:</span>
            <span class="n">actors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isosurfaces</span><span class="p">[</span><span class="n">iso_id</span><span class="p">])</span>
        <span class="n">actors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">actors</span></div>

<div class="viewcode-block" id="VolumeController.initialize"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clipping</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">slicer_box</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">center_on_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">add_to_scene</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the volume actor for visualization in VTK</span>
<span class="sd">        :param clipping: Whether clipping is enabled</span>
<span class="sd">        :param slicer_box: Whether the slicer box mode is enabled (6 clipping planes)</span>
<span class="sd">        :param center_on_edges: Whether the volume&#39;s center is aligned to its edges </span>
<span class="sd">            rather than the voxel center</span>
<span class="sd">        :param add_to_scene: Whether the object is added to the scene</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_actor</span><span class="p">(</span><span class="n">center_on_edges</span><span class="p">,</span> <span class="n">add_to_scene</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_picker</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">slicer_box</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize_slicer_box</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_clipping_planes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_volume_clipping</span><span class="p">(</span><span class="n">clipping</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_color_map</span><span class="p">()</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if use_mask:</span>
<span class="sd">            self.mask = self.actor.clone()</span>
<span class="sd">            self.mask.threshold(1, replace=1, replaceOut=0)</span>
<span class="sd">            self.actor.mapper().SetMaskTypeToBinary()</span>
<span class="sd">            self.actor.mapper().SetMaskInput(self.mask)</span>
<span class="sd">        &#39;&#39;&#39;</span></div>

<div class="viewcode-block" id="VolumeController.set_volume_visibility"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.set_volume_visibility">[docs]</a>    <span class="k">def</span> <span class="nf">set_volume_visibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set volume visibility</span>
<span class="sd">        :param on: Visibility boolean</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">SetVisibility</span><span class="p">(</span><span class="n">on</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.set_slices_visibility"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.set_slices_visibility">[docs]</a>    <span class="k">def</span> <span class="nf">set_slices_visibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the visibility of slices</span>
<span class="sd">        :param on: Visibility boolean</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">slicer_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">:</span>
            <span class="n">slicer_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">slicer_id</span><span class="p">)</span>
            <span class="n">slicer_view</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">SetVisibility</span><span class="p">(</span><span class="n">on</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.get_slices_opacity"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.get_slices_opacity">[docs]</a>    <span class="k">def</span> <span class="nf">get_slices_opacity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the opacity of slices (should be the same value for all slices)</span>
<span class="sd">        A mean calculation is performed on all slices alpha, just in case</span>
<span class="sd">        :return: Alpha value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">num_values</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">slicer_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">:</span>
            <span class="n">slicer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">[</span><span class="n">slicer_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">slicer</span><span class="o">.</span><span class="n">actor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slice_alpha</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">GetProperty</span><span class="p">()</span><span class="o">.</span><span class="n">GetOpacity</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">slice_alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">value</span> <span class="o">+=</span> <span class="n">slice_alpha</span>
                <span class="n">num_values</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">num_values</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">/</span> <span class="n">num_values</span></div>

<div class="viewcode-block" id="VolumeController.set_slices_opacity"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.set_slices_opacity">[docs]</a>    <span class="k">def</span> <span class="nf">set_slices_opacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the opacity of slices</span>
<span class="sd">        :param value: Alpha value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">slicer_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">:</span>
            <span class="n">slicer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">[</span><span class="n">slicer_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">slicer</span><span class="o">.</span><span class="n">actor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slicer</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">alpha</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.get_relative_opacity_unit"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.get_relative_opacity_unit">[docs]</a>    <span class="k">def</span> <span class="nf">get_relative_opacity_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the alpha unit relative value</span>
<span class="sd">        :return: Float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">alphaUnit</span><span class="p">()</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">resolution</span>
        <span class="c1"># Inverse function of set_opacity_unit()</span>
        <span class="n">value</span> <span class="o">=</span> <span class="mf">1.1</span> <span class="o">-</span> <span class="p">(</span><span class="n">alpha_unit</span> <span class="o">/</span> <span class="n">r</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">value</span></div>

<div class="viewcode-block" id="VolumeController.set_opacity"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.set_opacity">[docs]</a>    <span class="k">def</span> <span class="nf">set_opacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the opacity of the volume like in set_opacity_unit()</span>
<span class="sd">        :param value: Opacity value between 0.0 and 1.0</span>
<span class="sd">        :return: Resulting alpha unit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_opacity_unit</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.set_opacity_unit"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.set_opacity_unit">[docs]</a>    <span class="k">def</span> <span class="nf">set_opacity_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the opacity of the volume by modifying its alpha unit (a VTK thing).</span>
<span class="sd">        The alpha unit defines how much a voxel is transparent to incoming ray.</span>
<span class="sd">        This method normalizes the range between 0.0 and 1.0 as it depends</span>
<span class="sd">        on the resolution of the volume</span>
<span class="sd">        :param value: Opacity value between 0.0 and 1.0</span>
<span class="sd">        :return: Resulting alpha unit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">resolution</span>
        <span class="c1"># 1 is chosen and not 1.0 because when value == 1.0, that would</span>
        <span class="c1"># mean that the volume is fully opaque and this yields artifacts with VTK</span>
        <span class="n">alpha_unit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_unit_upper_offset</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span>
        <span class="c1"># vedo calls it &quot;alpha&quot; unit, vtk &quot;opacity&quot; unit. same-same!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">alphaUnit</span><span class="p">(</span><span class="n">alpha_unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">alpha_unit</span></div>

<div class="viewcode-block" id="VolumeController.get_spacing"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.get_spacing">[docs]</a>    <span class="k">def</span> <span class="nf">get_spacing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the spacing/resolution of the volume</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">resolution</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">res</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">spacing</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Given volume resolution </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">resolution</span><span class="si">}</span><span class="s1"> is invalid&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spacing</span></div>

<div class="viewcode-block" id="VolumeController.build_actor"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.build_actor">[docs]</a>    <span class="k">def</span> <span class="nf">build_actor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center_on_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">add_to_scene</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> <span class="c1">#[1, 2]</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the volume actor for visualization in VTK</span>
<span class="sd">        :param center_on_edges: Whether alignment by one voxel is applied</span>
<span class="sd">        :param add_to_scene: Whether the object is added to the scene</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spacing</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="o">=</span> <span class="n">Volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="s1">&#39;smart&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">GetScalars</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">shade</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">pickable</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_interactive_subsampling</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">center_on_edges</span><span class="p">:</span>
            <span class="c1"># Moving the volume by one voxel. This is possibly due the use of custom spacing.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">pos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">pos</span><span class="p">()</span> <span class="o">+</span> <span class="n">spacing</span><span class="p">)</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">pos</span><span class="p">())</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">center</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#print(&#39;Adjusting volume center from&#39;, self.model.center, &#39;to&#39;, center)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_opacity_unit</span><span class="p">(</span><span class="mf">0.9</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">jittering</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">#self.actor._mapper.AutoAdjustSampleDistancesOn()</span>
        <span class="c1">#self.actor._mapper.SetBlendModeToAverageIntensity()</span>
        <span class="c1">#self.actor._mapper.SetSampleDistance(100)</span>

        <span class="k">if</span> <span class="n">add_to_scene</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="p">,</span> <span class="n">render</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.set_position"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.set_position">[docs]</a>    <span class="k">def</span> <span class="nf">set_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the position of the volume</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">pos</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="c1"># TODO: we&#39;re entering in unstable things when we move the volume</span>
        <span class="c1"># because there is not yet a guaranteed support for updating the slices </span>
        <span class="c1"># with the correct position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_clipping_planes</span><span class="p">()</span></div>

<div class="viewcode-block" id="VolumeController.mirror_volume"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.mirror_volume">[docs]</a>    <span class="k">def</span> <span class="nf">mirror_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mirror the volume on given axes</span>
<span class="sd">        :param mirror_axes: A list of axes (either 0, 1, 2 or &#39;x&#39;, &#39;y&#39;, &#39;z&#39;) on which</span>
<span class="sd">            the volume will be mirrored. Optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">axes_str</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">axis</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">axes_str</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span></div>

<div class="viewcode-block" id="VolumeController.initialize_picker"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.initialize_picker">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_picker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opacity_iso_value</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the volume picker</span>
<span class="sd">        :param opacity_iso_value: Threshold that defines at what accumulated</span>
<span class="sd">            opacity the picker hits the volume. In the case of a segmented volume,</span>
<span class="sd">            you want to keep this value very low as the default one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># As per C++ doc https://vtk.org/Wiki/VTK/Examples/Cxx/VTKConcepts/Scalars</span>
        <span class="c1"># https://stackoverflow.com/questions/35378796/vtk-value-at-x-y-z-point </span>
        <span class="n">picker</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkVolumePicker</span><span class="p">()</span>
        <span class="n">picker</span><span class="o">.</span><span class="n">PickCroppingPlanesOn</span><span class="p">()</span>
        <span class="n">picker</span><span class="o">.</span><span class="n">UseVolumeGradientOpacityOff</span><span class="p">()</span>
        <span class="n">picker</span><span class="o">.</span><span class="n">SetTolerance</span><span class="p">(</span><span class="n">opacity_iso_value</span><span class="p">)</span>
        <span class="c1"># A low OpacityIsoValue is necessary in the case of segmented volumes</span>
        <span class="n">picker</span><span class="o">.</span><span class="n">SetVolumeOpacityIsovalue</span><span class="p">(</span><span class="n">opacity_iso_value</span><span class="p">)</span>
        <span class="n">picker</span><span class="o">.</span><span class="n">AddPickList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="p">)</span>
        <span class="n">picker</span><span class="o">.</span><span class="n">PickFromListOn</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">picker</span> <span class="o">=</span> <span class="n">picker</span></div>
    
<div class="viewcode-block" id="VolumeController.initialize_slicer_box"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.initialize_slicer_box">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_slicer_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize 6 slicing planes as a box.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">axis_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
            <span class="n">slicer_model</span> <span class="o">=</span> <span class="n">SlicerModel</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis_id</span><span class="p">)</span>
            <span class="n">slicer_model</span><span class="o">.</span><span class="n">align_to_axis</span><span class="p">(</span><span class="n">axis_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">slicers</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">slicer_model</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">[</span><span class="n">axis_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">SlicerView</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">slicer_model</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="VolumeController.update_slicer"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.update_slicer">[docs]</a>    <span class="k">def</span> <span class="nf">update_slicer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slicer_id</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update a given slicer with the given value</span>
<span class="sd">        :param slicer_id: SlicerView id</span>
<span class="sd">        :param value: Value or 3D point</span>
<span class="sd">        :param normal: Normal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slicer_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">slicer_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">slicer_view</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># This is an important part where the slicing plane is itself sliced by other planes</span>
        <span class="n">slicer_model</span> <span class="o">=</span> <span class="n">slicer_view</span><span class="o">.</span><span class="n">model</span>
        <span class="n">slicer_model</span><span class="o">.</span><span class="n">clipping_planes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_clipping_planes</span><span class="p">(</span><span class="n">slicer_model</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
        
        <span class="c1"># Use given value (or point) and normal to guide the below code</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">slicer_model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Update slicing image</span>
        <span class="n">slicer_view</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></div>

<div class="viewcode-block" id="VolumeController.initialize_clipping_planes"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.initialize_clipping_planes">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_clipping_planes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize X, Y and Z clipping planes with two planes per axis </span>
<span class="sd">        for positive and negative slicing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clipping_planes</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkPlaneCollection</span><span class="p">()</span>
        <span class="n">slicer_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">slicers</span>
        <span class="k">for</span> <span class="n">slicer_id</span> <span class="ow">in</span> <span class="n">slicer_models</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clipping_planes</span><span class="o">.</span><span class="n">AddItem</span><span class="p">(</span><span class="n">vtk</span><span class="o">.</span><span class="n">vtkPlane</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_clipping_planes</span><span class="p">()</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="VolumeController.get_clipping_planes"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.get_clipping_planes">[docs]</a>    <span class="k">def</span> <span class="nf">get_clipping_planes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">except_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the current clipping planes except the ones on the given axis</span>
<span class="sd">        :param except_axis: Axis id to ignore. If None, all clipping planes will be returned</span>
<span class="sd">        :return: vtkPlaneCollection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">except_axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clipping_planes</span>
        <span class="n">exceptions</span> <span class="o">=</span> <span class="p">[</span><span class="n">except_axis</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">except_axis</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">planes</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkPlaneCollection</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">plane_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clipping_planes</span><span class="o">.</span><span class="n">GetNumberOfItems</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">plane_id</span> <span class="ow">in</span> <span class="n">exceptions</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clipping_planes</span><span class="o">.</span><span class="n">GetItem</span><span class="p">(</span><span class="n">plane_id</span><span class="p">)</span>
            <span class="n">planes</span><span class="o">.</span><span class="n">AddItem</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">planes</span></div>

<div class="viewcode-block" id="VolumeController.reset_clipping_planes"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.reset_clipping_planes">[docs]</a>    <span class="k">def</span> <span class="nf">reset_clipping_planes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset clipping planes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slicer_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">slicers</span>
        <span class="k">for</span> <span class="n">slicer_id</span> <span class="ow">in</span> <span class="n">slicer_models</span><span class="p">:</span>
            <span class="n">slicer_model</span> <span class="o">=</span> <span class="n">slicer_models</span><span class="p">[</span><span class="n">slicer_id</span><span class="p">]</span>
            <span class="n">plane_id</span> <span class="o">=</span> <span class="n">slicer_model</span><span class="o">.</span><span class="n">get_box_plane_id</span><span class="p">()</span>
            <span class="n">plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clipping_planes</span><span class="o">.</span><span class="n">GetItem</span><span class="p">(</span><span class="n">plane_id</span><span class="p">)</span>
            <span class="n">plane</span><span class="o">.</span><span class="n">SetOrigin</span><span class="p">(</span><span class="n">slicer_model</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">pos</span><span class="p">())</span>
            <span class="n">plane</span><span class="o">.</span><span class="n">SetNormal</span><span class="p">(</span><span class="n">slicer_model</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.clip_on_axis"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.clip_on_axis">[docs]</a>    <span class="k">def</span> <span class="nf">clip_on_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply clipping on a single axis</span>
<span class="sd">        :param position: Position</span>
<span class="sd">        :param axis: Clipping axis, defaults to 0 (X axis)</span>
<span class="sd">        :param thickness: Whether a thickness (so two clipping planes) are applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># This should already be sorted in the model but in case it isn&#39;t, we double check here</span>
        <span class="k">if</span> <span class="n">normal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">normal</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># This means that the given axis has two </span>
            <span class="c1"># clipping planes and we take the negative one</span>
            <span class="n">axis_offset</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1">#position = self.model.dimensions - position</span>
        <span class="n">axis_storage_id</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">axis_offset</span>
        <span class="n">plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clipping_planes</span><span class="o">.</span><span class="n">GetItem</span><span class="p">(</span><span class="n">axis_storage_id</span><span class="p">)</span>
        <span class="n">plane</span><span class="o">.</span><span class="n">SetOrigin</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="n">plane</span><span class="o">.</span><span class="n">SetNormal</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.set_volume_clipping"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.set_volume_clipping">[docs]</a>    <span class="k">def</span> <span class="nf">set_volume_clipping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set volume clipping on or off</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">on</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">enable_volume_clipping</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_volume_clipping</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">enable_volume_clipping</span> <span class="o">=</span> <span class="n">on</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_volume_clipping</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">mapper</span><span class="p">()</span><span class="o">.</span><span class="n">SetClippingPlanes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clipping_planes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">mapper</span><span class="p">()</span><span class="o">.</span><span class="n">SetClippingPlanes</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>    </div>

<div class="viewcode-block" id="VolumeController.box_cutter_update"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.box_cutter_update">[docs]</a>    <span class="k">def</span> <span class="nf">box_cutter_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">widget</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">event</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clip the volume with the current box widget</span>
<span class="sd">        :param widget: vtkBoxCutter</span>
<span class="sd">        :param event: vtkEvent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">widget</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">clipping_planes</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkPlanes</span><span class="p">()</span>
        <span class="n">widget</span><span class="o">.</span><span class="n">GetPlanes</span><span class="p">(</span><span class="n">clipping_planes</span><span class="p">)</span>

        <span class="n">vtk_n</span> <span class="o">=</span> <span class="n">clipping_planes</span><span class="o">.</span><span class="n">GetNormals</span><span class="p">()</span>
        <span class="n">vtk_pts</span> <span class="o">=</span> <span class="n">clipping_planes</span><span class="o">.</span><span class="n">GetPoints</span><span class="p">()</span>
        <span class="n">num_pts</span> <span class="o">=</span> <span class="n">vtk_pts</span><span class="o">.</span><span class="n">GetNumberOfPoints</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">plane_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pts</span><span class="p">):</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">vtk_n</span><span class="o">.</span><span class="n">GetTuple</span><span class="p">(</span><span class="n">plane_id</span><span class="p">)</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">vtk_pts</span><span class="o">.</span><span class="n">GetPoint</span><span class="p">(</span><span class="n">plane_id</span><span class="p">)</span>
            <span class="n">plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clipping_planes</span><span class="o">.</span><span class="n">GetItem</span><span class="p">(</span><span class="n">plane_id</span><span class="p">)</span>
            <span class="n">current_origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">GetOrigin</span><span class="p">())</span>
            <span class="c1"># We don&#39;t need to check the normal because</span>
            <span class="c1"># we prevent box cutter rotation in our case</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">current_origin</span> <span class="o">-</span> <span class="n">origin</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">plane</span><span class="o">.</span><span class="n">SetOrigin</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
            <span class="n">plane</span><span class="o">.</span><span class="n">SetNormal</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_slicer</span><span class="p">(</span><span class="n">plane_id</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.set_alpha_map"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.set_alpha_map">[docs]</a>    <span class="k">def</span> <span class="nf">set_alpha_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha_map</span><span class="p">,</span> <span class="n">alpha_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set alpha map to the volume view</span>
<span class="sd">        :param alpha_map: 2D list of scalar values and alpha values</span>
<span class="sd">        :param alpha_factor: Alpha factor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">alpha_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">luts</span><span class="o">.</span><span class="n">current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">alpha_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">luts</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">alpha_map</span>
        <span class="k">if</span> <span class="n">alpha_factor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_factor</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alpha_map</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">volume_alpha_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">alpha_map</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">volume_alpha_map</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">alpha_map</span><span class="p">[:]</span>
            <span class="n">volume_alpha_map</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">alpha_factor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">alpha</span><span class="p">(</span><span class="n">volume_alpha_map</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">alpha</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alpha_map</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha_factor</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.set_color_map"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.set_color_map">[docs]</a>    <span class="k">def</span> <span class="nf">set_color_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the color and alpha map to the view objects</span>
<span class="sd">        :param color_map: Nested list of scalar values and rgb colors</span>
<span class="sd">            like [[0, [0.0, 0.0, 0.0]], [8, [0.5, 0.8, 0.3]], ...]</span>
<span class="sd">        :param alpha_map: 2D list of scalar values and alpha values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">luts</span><span class="o">.</span><span class="n">current</span>
        <span class="k">if</span> <span class="n">color_map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">color_map</span> <span class="o">=</span> <span class="n">lut</span><span class="o">.</span><span class="n">color_map</span>
        <span class="k">if</span> <span class="n">alpha_map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha_map</span> <span class="o">=</span> <span class="n">lut</span><span class="o">.</span><span class="n">alpha_map</span>
        <span class="k">if</span> <span class="n">color_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="n">color_map</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_alpha_map</span><span class="p">(</span><span class="n">alpha_map</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">lut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">isosurfaces</span><span class="p">:</span>
                <span class="n">surface</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">SetLookupTable</span><span class="p">(</span><span class="n">lut</span><span class="o">.</span><span class="n">opaque_lut</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">slicer_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">:</span>
                <span class="n">slicer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">[</span><span class="n">slicer_id</span><span class="p">]</span>
                <span class="n">slicer</span><span class="o">.</span><span class="n">apply_lut</span><span class="p">(</span><span class="n">lut</span><span class="o">.</span><span class="n">mapped_lut</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">slicer_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">:</span>
                <span class="n">slicer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">[</span><span class="n">slicer_id</span><span class="p">]</span>
                <span class="n">slicer</span><span class="o">.</span><span class="n">set_color_map</span><span class="p">(</span><span class="n">color_map</span><span class="p">,</span> <span class="n">alpha_map</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.disable_shading"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.disable_shading">[docs]</a>    <span class="k">def</span> <span class="nf">disable_shading</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disable volume shading</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">volumeProperty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">GetProperty</span><span class="p">()</span>
        <span class="n">volumeProperty</span><span class="o">.</span><span class="n">ShadeOff</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">SetProperty</span><span class="p">(</span><span class="n">volumeProperty</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.enable_shading"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.enable_shading">[docs]</a>    <span class="k">def</span> <span class="nf">enable_shading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ambient</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">diffuse</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">specular</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable volume shading</span>
<span class="sd">        TODO: See if this method is useful</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">volumeProperty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">GetProperty</span><span class="p">()</span>
        <span class="n">volumeProperty</span><span class="o">.</span><span class="n">SetInterpolationTypeToLinear</span><span class="p">()</span>
        <span class="n">volumeProperty</span><span class="o">.</span><span class="n">ShadeOn</span><span class="p">()</span>
        <span class="n">volumeProperty</span><span class="o">.</span><span class="n">SetAmbient</span><span class="p">(</span><span class="n">ambient</span><span class="p">)</span>
        <span class="n">volumeProperty</span><span class="o">.</span><span class="n">SetDiffuse</span><span class="p">(</span><span class="n">diffuse</span><span class="p">)</span>
        <span class="n">volumeProperty</span><span class="o">.</span><span class="n">SetSpecular</span><span class="p">(</span><span class="n">specular</span><span class="p">)</span>
        <span class="n">volumeProperty</span><span class="o">.</span><span class="n">SetScalarOpacityUnitDistance</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">SetProperty</span><span class="p">(</span><span class="n">volumeProperty</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.toggle_slices_visibility"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.toggle_slices_visibility">[docs]</a>    <span class="k">def</span> <span class="nf">toggle_slices_visibility</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Toggle slices visibility</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">slices_visible</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">slices_visible</span>
        <span class="k">for</span> <span class="n">slicer_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">:</span>
            <span class="n">slicer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">[</span><span class="n">slicer_id</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_slicer</span><span class="p">(</span><span class="n">slicer</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">slicer</span><span class="o">.</span><span class="n">actor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slicer</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">SetVisibility</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">slices_visible</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.toggle_hollow"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.toggle_hollow">[docs]</a>    <span class="k">def</span> <span class="nf">toggle_hollow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Toggle hollow mode for volume rendering. This is intended to work only on segmented (annotated) volumes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">volume_property</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">GetProperty</span><span class="p">()</span>
        <span class="c1"># Shout at VTK devs: it&#39;s twisted to name properties Disable and then have DisableOff...</span>
        <span class="n">disabled</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">volume_property</span><span class="o">.</span><span class="n">GetDisableGradientOpacity</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">disabled</span><span class="p">:</span>
            <span class="n">volume_property</span><span class="o">.</span><span class="n">DisableGradientOpacityOff</span><span class="p">()</span>
            <span class="n">alpha_gradient</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkPiecewiseFunction</span><span class="p">()</span>
            <span class="n">alpha_gradient</span><span class="o">.</span><span class="n">AddPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">alpha_gradient</span><span class="o">.</span><span class="n">AddPoint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">)</span>
            <span class="n">alpha_gradient</span><span class="o">.</span><span class="n">AddPoint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">volume_property</span><span class="o">.</span><span class="n">SetGradientOpacity</span><span class="p">(</span><span class="n">alpha_gradient</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">volume_property</span><span class="o">.</span><span class="n">DisableGradientOpacityOn</span><span class="p">()</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">disabled</span></div>

<div class="viewcode-block" id="VolumeController.get_value_from_xyz"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.get_value_from_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">get_value_from_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">normal_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">avoid_values</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">cast_to_int</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a scalar value from the volume with respect to XYZ coordinates and a optionally a normal step,</span>
<span class="sd">        which is the normal on which to probe multiplied by the distance you want to travel further into</span>
<span class="sd">        the volume to pick a correct value. Often the &quot;surface point&quot; on a volume with non uniform transparency</span>
<span class="sd">        is at the boundary between transparent (let&#39;s say a 0 value is transparent) and more opaque parts.</span>
<span class="sd">        So you need to go further into the &quot;cloud&quot; so to speak, in order to find the values you want.</span>
<span class="sd">        :param position: 3D array</span>
<span class="sd">        :param normal_step: A vector normal multiplied by the lookup distance, in case the raw position yields</span>
<span class="sd">            bad or unwanted results</span>
<span class="sd">        :param avoid_values: Try and find other values than this</span>
<span class="sd">        :param cast_to_int: Whether the value should be cast to integer</span>
<span class="sd">        :return: Scalar value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">avoid_values</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">avoid_values</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">avoid_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">avoid_values</span><span class="p">]</span>
        <span class="n">pt_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">FindPoint</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">)</span>
        <span class="n">valid_id</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">pt_id</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">GetNumberOfValues</span><span class="p">()</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">GetValue</span><span class="p">(</span><span class="n">pt_id</span><span class="p">)</span> <span class="k">if</span> <span class="n">valid_id</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_id</span> <span class="ow">or</span> <span class="p">(</span><span class="n">value</span> <span class="ow">in</span> <span class="n">avoid_values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">normal_step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">position</span> <span class="o">+=</span> <span class="n">normal_step</span>
                <span class="n">pt_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">FindPoint</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">)</span>
                <span class="n">valid_id</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">pt_id</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">GetNumberOfValues</span><span class="p">()</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">GetValue</span><span class="p">(</span><span class="n">pt_id</span><span class="p">)</span> <span class="k">if</span> <span class="n">valid_id</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">cast_to_int</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></div>

<div class="viewcode-block" id="VolumeController.pick"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.pick">[docs]</a>    <span class="k">def</span> <span class="nf">pick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">screen_position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the nearest intersection given a vector formed by two coordinates.</span>
<span class="sd">        This function relies on a trick, using surface meshes to get the proper first intersection</span>
<span class="sd">        and this works with slicers as well.</span>
<span class="sd">        :param origin: Origin of the vector</span>
<span class="sd">        :param screen_position: 2D position on screen. This is given by vtk events like MouseRelease</span>
<span class="sd">        :return: The nearest position and its related value queried in the volume image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">picker</span><span class="o">.</span><span class="n">Pick</span><span class="p">(</span><span class="o">*</span><span class="n">screen_position</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">renderer</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">picker</span><span class="o">.</span><span class="n">GetPickPosition</span><span class="p">())</span>
        <span class="n">ray</span> <span class="o">=</span> <span class="n">position</span> <span class="o">-</span> <span class="n">origin</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ray</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">ray</span> <span class="o">/</span> <span class="n">distance</span>

        <span class="c1"># Go half a voxel further to make sure we don&#39;t hit &quot;void&quot;</span>
        <span class="n">vol_position</span> <span class="o">=</span> <span class="n">position</span> <span class="c1"># + normal * self.model.resolution / 2</span>
        <span class="n">probe_position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">normal</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">resolution</span> <span class="o">*</span> <span class="mi">10</span>

        <span class="n">closest_dist</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="n">slice_position</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">slicer_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">:</span>
            <span class="n">slicer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slicers</span><span class="p">[</span><span class="n">slicer_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">slicer</span><span class="o">.</span><span class="n">got_slice</span><span class="p">:</span>
                <span class="n">hits</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">intersectWithLine</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">probe_position</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hits</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">new_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">hits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">new_dist</span> <span class="o">&lt;</span> <span class="n">closest_dist</span> <span class="ow">and</span> <span class="n">new_dist</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">resolution</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">closest_dist</span> <span class="o">=</span> <span class="n">new_dist</span>
                    <span class="c1">#print(&#39;Found closer position on slice!&#39;, slicer_id, np.linalg.norm(hits[0] - origin), distance)</span>
                    <span class="n">slice_position</span> <span class="o">=</span> <span class="n">hits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">slice_position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">vol_position</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">slice_position</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value_from_xyz</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">normal</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">resolution</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="n">value</span></div>

<div class="viewcode-block" id="VolumeController.probe"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.probe">[docs]</a>    <span class="k">def</span> <span class="nf">probe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">picker</span><span class="o">.</span><span class="n">IntersectVolumeWithLine</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span> <span class="o">-</span> <span class="n">origin</span><span class="p">)</span></div>

<div class="viewcode-block" id="VolumeController.set_interactive_subsampling"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.set_interactive_subsampling">[docs]</a>    <span class="k">def</span> <span class="nf">set_interactive_subsampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set volume subsampling on or off. </span>
<span class="sd">        This is enabled by default in VTK and we disable it by default in IBLViewer</span>
<span class="sd">        :param on: Whether volume subsampling in interactive mode is on or off</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#self.plot.window.SetDesiredUpdateRate(0)</span>
        <span class="c1">#self.actor._mapper.SetInteractiveUpdateRate(0)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">interactive_subsampling</span> <span class="o">=</span> <span class="n">on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">SetAutoAdjustSampleDistances</span><span class="p">(</span><span class="n">on</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">on</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">InteractiveAdjustSampleDistancesOn</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">InteractiveAdjustSampleDistancesOff</span><span class="p">()</span></div>

<div class="viewcode-block" id="VolumeController.remesh_surface"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.remesh_surface">[docs]</a>    <span class="k">def</span> <span class="nf">remesh_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This remesher cleans and smoothes a given mesh.</span>
<span class="sd">        This is useful in the case of extracting surface meshes</span>
<span class="sd">        from volumes, which most of the times yield jagged meshes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="kn">import</span> <span class="nn">trimesh</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">vedo2trimesh</span><span class="p">(</span><span class="n">actor</span><span class="p">)</span>
        <span class="n">trimesh</span><span class="o">.</span><span class="n">smoothing</span><span class="o">.</span><span class="n">filter_laplacian</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">actor</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">trimesh2vedo</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        
        <span class="n">pdnorm</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkPolyDataNormals</span><span class="p">()</span>
        <span class="n">pdnorm</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="n">actor</span><span class="o">.</span><span class="n">_polydata</span><span class="p">)</span>
        <span class="n">pdnorm</span><span class="o">.</span><span class="n">SetComputePointNormals</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pdnorm</span><span class="o">.</span><span class="n">SetComputeCellNormals</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pdnorm</span><span class="o">.</span><span class="n">SetConsistency</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pdnorm</span><span class="o">.</span><span class="n">FlipNormalsOff</span><span class="p">()</span>
        <span class="n">pdnorm</span><span class="o">.</span><span class="n">SetSplitting</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pdnorm</span><span class="o">.</span><span class="n">SetFeatureAngle</span><span class="p">(</span><span class="mi">89</span><span class="p">)</span>
        <span class="c1"># print(pdnorm.GetNonManifoldTraversal())</span>
        <span class="n">pdnorm</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">_polydata</span> <span class="o">=</span> <span class="n">pdnorm</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">()</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="n">actor</span><span class="o">.</span><span class="n">_polydata</span><span class="p">)</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">Modified</span><span class="p">()</span>

        <span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">SetScalarRange</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">scalar_max</span><span class="p">)</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">SetScalarModeToUsePointData</span><span class="p">()</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">ScalarVisibilityOn</span><span class="p">()</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">SetLookupTable</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">opaque_lut</span><span class="p">)</span>

        <span class="n">scalars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">label</span><span class="p">]</span><span class="o">*</span><span class="n">actor</span><span class="o">.</span><span class="n">_polydata</span><span class="o">.</span><span class="n">GetNumberOfPoints</span><span class="p">())</span>
        <span class="n">scalars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span>
        <span class="n">vtk_scalars</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">numpy_support</span><span class="o">.</span><span class="n">numpy_to_vtk</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vtk_scalars</span><span class="o">.</span><span class="n">SetName</span><span class="p">(</span><span class="s1">&#39;scalars&#39;</span><span class="p">)</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">_polydata</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">SetScalars</span><span class="p">(</span><span class="n">vtk_scalars</span><span class="p">)</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">_polydata</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">SetActiveScalars</span><span class="p">(</span><span class="s1">&#39;scalars&#39;</span><span class="p">)</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">_polydata</span><span class="o">.</span><span class="n">GetPointData</span><span class="p">()</span><span class="o">.</span><span class="n">Modified</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">actor</span></div>
        <span class="c1">#actor.decimate(0.1).smoothMLS2D().clean()</span>
        <span class="c1">#actor.alpha(0.8)</span>
        <span class="c1">#test = self.view.volume.actor.legosurface(vmin=regions, vmax=regions)</span>
        <span class="c1">#test.alpha(0.8)</span>
        <span class="c1">#actor = thresholded_volume.isosurface(1)</span>

<div class="viewcode-block" id="VolumeController.build_surface"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.VolumeController.build_surface">[docs]</a>    <span class="k">def</span> <span class="nf">build_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">force_rebuild</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a surface mesh (isosurface) of a volume for the given value.</span>
<span class="sd">        Unlike general isosurfacing, this method thresholds the volume to the desired</span>
<span class="sd">        label (by making a copy of it, yes it&#39;s slow but can&#39;t do it otherwise...) </span>
<span class="sd">        and then uses vtkFlyingEdges3d to extract the surface of the desired region/label/segmentation.</span>
<span class="sd">        This is the only way to extract a specific label because regular isosurfacing includes</span>
<span class="sd">        everything below the given value, which is clearly unwanted in segmented volumes.</span>
<span class="sd">        The raw result needs some smoothing in general but that is left to other methods.</span>
<span class="sd">        </span>
<span class="sd">        :param label: Label (scalar) value found in the volume</span>
<span class="sd">        :param exceptions: If the label is found in the exceptions list, isosurfacing will not occur</span>
<span class="sd">        :param force_rebuild: Whether rebuilding is forced in case we find an existing mesh for the given label</span>
<span class="sd">        :return: Mesh actor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">exceptions</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isosurfaces</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isosurfaces</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="n">iso_surface</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkFlyingEdges3D</span><span class="p">()</span>
        <span class="n">iso_surface</span><span class="o">.</span><span class="n">ComputeNormalsOn</span><span class="p">()</span>
        <span class="n">iso_surface</span><span class="o">.</span><span class="n">ComputeScalarsOn</span><span class="p">()</span>
        
        <span class="n">lut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">luts</span><span class="o">.</span><span class="n">current</span>
        <span class="c1"># TODO: replace lut.scalar_min with actual value from LUT</span>
        <span class="n">min_value</span> <span class="o">=</span> <span class="n">lut</span><span class="o">.</span><span class="n">scalar_min</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="c1">#thresholded_volume = clone.threshold(label, label, replaceOut=-min_value-1)</span>
        <span class="n">clone_threshold</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkImageThreshold</span><span class="p">()</span>
        <span class="n">clone_threshold</span><span class="o">.</span><span class="n">ThresholdBetween</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
        <span class="n">clone_threshold</span><span class="o">.</span><span class="n">SetOutValue</span><span class="p">(</span><span class="o">-</span><span class="n">min_value</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">clone_threshold</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="n">clone</span><span class="o">.</span><span class="n">imagedata</span><span class="p">())</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        radius = 1</span>
<span class="sd">        std_deviation = 2.0</span>
<span class="sd">        gaussian = vtk.vtkImageGaussianSmooth()</span>
<span class="sd">        gaussian.SetStandardDeviations(std_deviation, std_deviation, std_deviation)</span>
<span class="sd">        gaussian.SetRadiusFactors(radius, radius, radius)</span>
<span class="sd">        gaussian.SetInputConnection(clone_threshold.GetOutputPort())</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">iso_surface</span><span class="o">.</span><span class="n">SetInputConnection</span><span class="p">(</span><span class="n">clone_threshold</span><span class="o">.</span><span class="n">GetOutputPort</span><span class="p">())</span>
        <span class="c1">#iso_surface.SetInputData(thresholded_volume.imagedata())</span>
        <span class="n">iso_surface</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
        <span class="n">iso_surface</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">iso_surface</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">()</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        decimate = vtk.vtkDecimatePro()</span>
<span class="sd">        decimate.SetInputConnection(iso_surface.GetOutputPort())</span>
<span class="sd">        decimate.SetTargetReduction(0.1)</span>
<span class="sd">        decimate.Update()</span>

<span class="sd">        smoothing_iterations = 100</span>
<span class="sd">        pass_band = 0.5</span>
<span class="sd">        feature_angle = 80.0</span>
<span class="sd">        smoother = vtk.vtkWindowedSincPolyDataFilter()</span>
<span class="sd">        smoother.SetInputConnection(decimate.GetOutputPort())</span>
<span class="sd">        smoother.SetNumberOfIterations(smoothing_iterations)</span>
<span class="sd">        smoother.BoundarySmoothingOff()</span>
<span class="sd">        smoother.FeatureEdgeSmoothingOff()</span>
<span class="sd">        smoother.SetFeatureAngle(feature_angle)</span>
<span class="sd">        smoother.SetPassBand(pass_band)</span>
<span class="sd">        smoother.NonManifoldSmoothingOn()</span>
<span class="sd">        smoother.NormalizeCoordinatesOff()</span>
<span class="sd">        smoother.Update()</span>

<span class="sd">        poly = smoother.GetOutput()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">actor</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">SetScalarRange</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">lut</span><span class="o">.</span><span class="n">scalar_max</span><span class="p">)</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">SetLookupTable</span><span class="p">(</span><span class="n">lut</span><span class="o">.</span><span class="n">opaque_table</span><span class="p">)</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span><span class="o">.</span><span class="n">ScalarVisibilityOn</span><span class="p">()</span>
        <span class="n">actor</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Isosurface &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isosurfaces</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">actor</span>
        <span class="k">return</span> <span class="n">actor</span></div></div>


<div class="viewcode-block" id="SlicerModel"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerModel">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">SlicerModel</span><span class="p">:</span>
    <span class="n">PREFIX</span> <span class="o">=</span> <span class="s1">&#39;[Slicer]_&#39;</span>
    <span class="n">MIN_SLAB_THICKNESS</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1">#um</span>

    <span class="n">__count</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="SlicerModel.unique_name"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerModel.unique_name">[docs]</a>    <span class="k">def</span> <span class="nf">unique_name</span><span class="p">():</span>
        <span class="n">SlicerModel</span><span class="o">.</span><span class="n">__count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">SlicerModel</span><span class="o">.</span><span class="n">PREFIX</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">SlicerModel</span><span class="o">.</span><span class="n">__count</span><span class="si">}</span><span class="s1">&#39;</span></div>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">unique_name</span><span class="p">)</span>
    <span class="c1"># 0, 1 or 2. See the normal for axis orientation</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1">#thickness: float = 0.0</span>
    <span class="n">origin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="n">normal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="n">clipping_planes</span><span class="p">:</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkPlaneCollection</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="SlicerModel.get_box_plane_id"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerModel.get_box_plane_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_box_plane_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the plane id</span>
<span class="sd">        :return: Int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">offset</span></div>

<div class="viewcode-block" id="SlicerModel.get_axis_aligned_info"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerModel.get_axis_aligned_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_axis_aligned_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vtk_axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        VTK stores box clipping planes in the order:</span>
<span class="sd">        -X to +X: 0, 1</span>
<span class="sd">        -Y to +Y: 2, 3</span>
<span class="sd">        -Z to +Z: 4, 5</span>
<span class="sd">        This method retrieves what is the XYZ axis (0, 1 or 2)</span>
<span class="sd">        and its orientation sign</span>
<span class="sd">        :return: Int axis and float orientation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">vtk_axis</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">vtk_axis</span> <span class="o">-</span> <span class="n">vtk_axis</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">axis</span><span class="p">,</span> <span class="n">orientation</span></div>

<div class="viewcode-block" id="SlicerModel.align_to_axis"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerModel.align_to_axis">[docs]</a>    <span class="k">def</span> <span class="nf">align_to_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the axis of the slicer</span>
<span class="sd">        :param axis: See parameter vtk_axis in SlicerModel.get_axis_aligned_info()</span>
<span class="sd">        :param dimensions: Dimensions of the volume</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">xyz_axis</span><span class="p">,</span> <span class="n">orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_axis_aligned_info</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">normal</span><span class="p">[</span><span class="n">xyz_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">orientation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">xyz_axis</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orientation</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="n">xyz_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">xyz_axis</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">normal</span></div>

<div class="viewcode-block" id="SlicerModel.flip_normal"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerModel.flip_normal">[docs]</a>    <span class="k">def</span> <span class="nf">flip_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flip the normal of the slicer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_normal</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="SlicerModel.check_normal"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerModel.check_normal">[docs]</a>    <span class="k">def</span> <span class="nf">check_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the normal is axis-aligned.</span>
<span class="sd">        If not, the axis is set to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="n">zeros</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="SlicerModel.update"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerModel.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update slicer</span>
<span class="sd">        :param value: Origin of the slicing plane</span>
<span class="sd">        :param normal: Normal of the slicing plane</span>
<span class="sd">        :param axis: Axis, if the plane is axis-aligned</span>
<span class="sd">        :return: True if model changed, False if it didn&#39;t</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">normal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
            <span class="k">if</span> <span class="n">normal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#if normal[0] &gt; 0 else 1</span>
            <span class="k">elif</span> <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">#if normal[1] &gt; 0 else 1</span>
            <span class="k">elif</span> <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1">#if normal[2] &gt; 0 else 1</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="k">return</span> <span class="kc">True</span></div></div>


<div class="viewcode-block" id="SlicerView"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerView">[docs]</a><span class="k">class</span> <span class="nc">SlicerView</span><span class="p">():</span>

    <span class="n">slices</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot</span><span class="p">,</span> <span class="n">volume_view</span><span class="p">,</span> <span class="n">slicer_model</span><span class="p">,</span> <span class="n">standalone</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>
<span class="sd">        :param plot: Plot instance</span>
<span class="sd">        :param volume_view: VolumeView instance</span>
<span class="sd">        :param slicer_model: SlicerModel instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if SlicerView.slices.get(volume_view) is None:</span>
<span class="sd">            SlicerView.slices[volume_view] = []</span>
<span class="sd">        SlicerView.slices[volume_view].append(self)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume_view</span> <span class="o">=</span> <span class="n">volume_view</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">slicer_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reslice</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slice_type</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">standalone</span> <span class="o">=</span> <span class="n">standalone</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">got_slice</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_map</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_map</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

<div class="viewcode-block" id="SlicerView.initialize"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerView.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">render</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the slicer object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkImageDataGeometryFilter</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
            <span class="c1"># Adding empty actor so that it&#39;s updated later on</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="p">,</span> <span class="n">render</span><span class="o">=</span><span class="n">render</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">lighting</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_mapper</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standalone</span><span class="p">:</span>
            <span class="c1"># As per a bug in VTK 9 that I found while using vedo that makes pickable fail when</span>
            <span class="c1"># there is transparency as per https://github.com/marcomusy/vedo/issues/291</span>
            <span class="c1"># Force opaque fix should be gone with the next update of VTK (hopefully...)</span>
            <span class="c1"># In the meantime, this option yields unwanted light artifacts</span>
            <span class="k">pass</span> <span class="c1">#self.actor.ForceOpaqueOn()</span>
        <span class="c1"># We bypass the bug when a VolumeView has multiple slicers like in box mode</span>
        <span class="c1"># because the click detection occurs on the volume and we perform an additional</span>
        <span class="c1"># test to see if a slicer yields a nearby result. If it does, the result is like</span>
        <span class="c1"># clicking on the slice and we get transparency for free.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">pickable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">standalone</span><span class="p">)</span>

        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        slice_center = self.actor.centerOfMass()</span>
<span class="sd">        interactor_plane = Plane(pos=slice_center, normal=normal, sx=10000).alpha(0.2)</span>
<span class="sd">        interactor_plane.c(&#39;white&#39;)</span>
<span class="sd">        interactor_plane.ForceOpaqueOn()</span>
<span class="sd">        interactor_plane.pickable(True) </span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="SlicerView.initialize_mapper"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerView.initialize_mapper">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_mapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the object mapper</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span>
        <span class="n">mapper</span><span class="o">.</span><span class="n">SetScalarModeToUsePointData</span><span class="p">()</span> <span class="c1">#SetScalarModeToUsePointFieldData</span>
        <span class="n">mapper</span><span class="o">.</span><span class="n">SetColorModeToMapScalars</span><span class="p">()</span>
        <span class="n">mapper</span><span class="o">.</span><span class="n">ScalarVisibilityOn</span><span class="p">()</span>
        <span class="n">mapper</span><span class="o">.</span><span class="n">SetStatic</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Without using scalar range, the mapping will be off</span>
        <span class="n">mapper</span><span class="o">.</span><span class="n">SetUseLookupTableScalarRange</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># This very line below will mess up the entire slice coloring if:</span>
        <span class="c1"># - you have a segmented volume and this is set to True</span>
        <span class="c1"># - you have a non-segmented (like raw MRI, CT) volume and this is set to False</span>
        <span class="n">segmented</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume_view</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">is_segmented</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">segmented</span><span class="p">:</span>
            <span class="n">mapper</span><span class="o">.</span><span class="n">SetInterpolateScalarsBeforeMapping</span><span class="p">(</span><span class="ow">not</span> <span class="n">segmented</span><span class="p">)</span>
        <span class="n">mapper</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span></div>

<div class="viewcode-block" id="SlicerView.set_color_map"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerView.set_color_map">[docs]</a>    <span class="k">def</span> <span class="nf">set_color_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color_map</span><span class="p">,</span> <span class="n">alpha_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a color map to the slice</span>
<span class="sd">        :param color_map: Color map, can be a string, a list of colors or more. </span>
<span class="sd">            See vedo documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_map</span> <span class="o">=</span> <span class="n">color_map</span>
        <span class="k">if</span> <span class="n">alpha_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha_map</span> <span class="o">=</span> <span class="n">alpha_map</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">got_slice</span> <span class="ow">and</span> <span class="n">color_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">color_map</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_map</span><span class="p">)</span></div>

<div class="viewcode-block" id="SlicerView.set_slice_type"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerView.set_slice_type">[docs]</a>    <span class="k">def</span> <span class="nf">set_slice_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slice_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the slice type. 0 for axial, 1 for free slicing</span>
<span class="sd">        :param slice_type: Int value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">slice_type</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_type</span> <span class="o">!=</span> <span class="n">slice_type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slice_type</span> <span class="o">=</span> <span class="n">slice_type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume_view</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">imagedata</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">slice_type</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_type</span> <span class="o">!=</span> <span class="n">slice_type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slice_type</span> <span class="o">=</span> <span class="n">slice_type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reslice</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span></div>

<div class="viewcode-block" id="SlicerView.slice_on_normal"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerView.slice_on_normal">[docs]</a>    <span class="k">def</span> <span class="nf">slice_on_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">normal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slice a volume with a plane oriented by the given normal.</span>
<span class="sd">        This allows slicing in all directions.</span>
<span class="sd">        :param origin: Origin of the slicing plane</span>
<span class="sd">        :param normal: Normal of the slicing plane</span>
<span class="sd">        :return: Mesh object with the slice as an image texture</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        mapper = vtk.vtkImageResliceMapper()</span>
<span class="sd">        mapper.SetInputData(self.volume_view.actor._data)</span>
<span class="sd">        mapper.SliceFacesCameraOff()</span>
<span class="sd">        mapper.SliceAtFocalPointOff()</span>
<span class="sd">        mapper.JumpToNearestSliceOn()</span>
<span class="sd">        mapper.SetImageSampleFactor(2)</span>
<span class="sd">        mapper.BorderOn()</span>
<span class="sd">        mapper.BackgroundOff()</span>
<span class="sd">        mapper.UpdateInformation()</span>
<span class="sd">        mapper.GetSlicePlane().SetOrigin(*origin)</span>
<span class="sd">        mapper.GetSlicePlane().SetNormal(*normal)</span>
<span class="sd">        mapper.GetSlicePlane().Modified()</span>
<span class="sd">        mapper.Modified()</span>
<span class="sd">        mapper.Update()</span>

<span class="sd">        self.actor = vtk.vtkImageSlice()</span>
<span class="sd">        self.actor.SetMapper(mapper)</span>
<span class="sd">        prop = vtk.vtkImageProperty()</span>
<span class="sd">        if True:</span>
<span class="sd">            prop.SetInterpolationTypeToLinear()</span>
<span class="sd">        else:</span>
<span class="sd">            prop.SetInterpolationTypeToNearest()</span>
<span class="sd">        self.actor.SetProperty(prop)</span>
<span class="sd">        return</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reslice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reslice</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkImageReslice</span><span class="p">()</span>
            <span class="n">reslice</span><span class="o">.</span><span class="n">SetInputData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume_view</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
            <span class="c1">#reslice.SetInputData(image)</span>
            <span class="n">reslice</span><span class="o">.</span><span class="n">SetOutputDimensionality</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">reslice</span><span class="o">.</span><span class="n">SetAutoCropOutput</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1">#reslice.SetInterpolationModeToLinear()</span>
            <span class="n">reslice</span><span class="o">.</span><span class="n">SetInterpolationModeToNearestNeighbor</span><span class="p">()</span>
            <span class="n">reslice</span><span class="o">.</span><span class="n">SetSlabNumberOfSlices</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">reslice</span><span class="o">.</span><span class="n">SetOutputSpacing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume_view</span><span class="o">.</span><span class="n">get_spacing</span><span class="p">())</span>
            <span class="n">reslice</span><span class="o">.</span><span class="n">ReleaseDataFlagOn</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reslice</span> <span class="o">=</span> <span class="n">reslice</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_slice_type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_transformation_matrix</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reslice</span><span class="o">.</span><span class="n">SetResliceAxes</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reslice</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize_mapper</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_mapper</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">SetOrientation</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">GetOrientation</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">SetPosition</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">got_slice</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span></div>

<div class="viewcode-block" id="SlicerView.x_slice"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerView.x_slice">[docs]</a>    <span class="k">def</span> <span class="nf">x_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the slice at index `i` of volume along x-axis.</span>
<span class="sd">        :param i: I index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_slice_type</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume_view</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">imagedata</span><span class="p">()</span><span class="o">.</span><span class="n">GetDimensions</span><span class="p">()</span>
        <span class="c1">#if i &gt; nx-1:</span>
            <span class="c1">#i = nx-1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">SetExtent</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize_mapper</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">got_slice</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span></div>

<div class="viewcode-block" id="SlicerView.y_slice"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerView.y_slice">[docs]</a>    <span class="k">def</span> <span class="nf">y_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the slice at index `j` of volume along y-axis.</span>
<span class="sd">        :param j: J index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_slice_type</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume_view</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">imagedata</span><span class="p">()</span><span class="o">.</span><span class="n">GetDimensions</span><span class="p">()</span>
        <span class="c1">#if j &gt; ny-1:</span>
            <span class="c1">#j = ny-1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">SetExtent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize_mapper</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">got_slice</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span></div>

<div class="viewcode-block" id="SlicerView.z_slice"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerView.z_slice">[docs]</a>    <span class="k">def</span> <span class="nf">z_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract the slice at index `k` of volume along z-axis.</span>
<span class="sd">        :param k: K index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_slice_type</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume_view</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">imagedata</span><span class="p">()</span><span class="o">.</span><span class="n">GetDimensions</span><span class="p">()</span>
        <span class="c1">#if k &gt; nz-1:</span>
            <span class="c1">#k = nz-1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">SetExtent</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">Update</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="o">=</span> <span class="n">vedo</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">GetOutput</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize_mapper</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">got_slice</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span></div>

<div class="viewcode-block" id="SlicerView.slice_on_axis"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerView.slice_on_axis">[docs]</a>    <span class="k">def</span> <span class="nf">slice_on_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_reslice</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slice on standard X, Y or Z axis</span>
<span class="sd">        :param value: Value on the given axis</span>
<span class="sd">        :param normal: Axis normal, can be either +1.0 or -1.0 along that axis</span>
<span class="sd">        :param axis: Axis integer, 0 for X, 1 for Y, 2 for Z</span>
<span class="sd">        :param use_reslice: if True, this enables vtkImageReslice which is useful when</span>
<span class="sd">            the normal is not aligned to either X, Y or Z. If you use it on an axis-aligned</span>
<span class="sd">            normal, some color inaccuracies will appear if you don&#39;t tweak the vtkImageResliceMapper.</span>
<span class="sd">            This is why the default is False.</span>
<span class="sd">        :return: Mesh actor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume_view</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">resolution</span>
        <span class="n">volume_dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume_view</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if normal[axis] &lt; 0:</span>
<span class="sd">            if value &gt; 0:</span>
<span class="sd">                # Make value consistent with given normal.</span>
<span class="sd">                value *= normal[axis]</span>
<span class="sd">            value = volume_dimensions[axis] + value</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">in_volume_slice</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">//</span> <span class="n">resolution</span>

        <span class="k">if</span> <span class="n">use_reslice</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slice_on_normal</span><span class="p">(</span><span class="n">normal</span> <span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_slice</span><span class="p">(</span><span class="n">in_volume_slice</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">new_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_slice</span><span class="p">(</span><span class="n">in_volume_slice</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_slice</span><span class="p">(</span><span class="n">in_volume_slice</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_slice</span></div>

<div class="viewcode-block" id="SlicerView.update"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerView.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update slice object according to data in the model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">had_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">got_slice</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">axis</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slice_on_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slice_on_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="c1">#self.actor.pos(*(self.volume_view.actor.pos()-self.actor.pos()))</span>

        <span class="c1">#if not (not had_slice and self.got_slice):</span>
            <span class="c1">#return</span>
        <span class="n">lut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume_view</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">luts</span><span class="o">.</span><span class="n">current</span>
        <span class="k">if</span> <span class="n">lut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            This is VTK for you...a mesh can use a vtkLookupTable for RGBA mapping</span>
<span class="sd">            BUT volumes require vtkColorTransferFunction (RGB) and vtkPiecewiseFunction (alpha)</span>
<span class="sd">            So we have to put a color map, alpha map and a vtkLookupTable </span>
<span class="sd">            built from both maps in a LUTModel.</span>
<span class="sd">            Alternatively, we could update the LUT with alpha values but it&#39;s a pain.</span>
<span class="sd">            </span>
<span class="sd">            ctf = self.volume_view.actor.GetProperty().GetRGBTransferFunction()</span>
<span class="sd">            otf = self.volume_view.actor.GetProperty().GetScalarOpacity</span>
<span class="sd">            lut = vedo.utils.ctf2lut(self.volume_view.actor)</span>

<span class="sd">            # using &quot;ctf&quot; would work only for colors, not for transparency!</span>
<span class="sd">            self.apply_lut(ctf)</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_lut</span><span class="p">(</span><span class="n">lut</span><span class="o">.</span><span class="n">mapped_lut</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">color_map</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">color_map</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha_map</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">clipping_planes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">mapper</span><span class="p">()</span><span class="o">.</span><span class="n">SetClippingPlanes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">clipping_planes</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">had_slice</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="p">,</span> <span class="n">render</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="SlicerView.apply_lut"><a class="viewcode-back" href="../../_autosummary/iblviewer.volume.html#iblviewer.volume.SlicerView.apply_lut">[docs]</a>    <span class="k">def</span> <span class="nf">apply_lut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lut</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a LUT to the volume</span>
<span class="sd">        :param lut: vtkLookupTable</span>
<span class="sd">        :param actor: The actor to receive this</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">lut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actor</span><span class="o">.</span><span class="n">_mapper</span>
        <span class="n">mapper</span><span class="o">.</span><span class="n">SetLookupTable</span><span class="p">(</span><span class="n">lut</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, International Brain Laboratory

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>